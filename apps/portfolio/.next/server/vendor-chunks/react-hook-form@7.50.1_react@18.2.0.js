"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-hook-form@7.50.1_react@18.2.0";
exports.ids = ["vendor-chunks/react-hook-form@7.50.1_react@18.2.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/react-hook-form@7.50.1_react@18.2.0/node_modules/react-hook-form/dist/index.esm.mjs":
/*!********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/react-hook-form@7.50.1_react@18.2.0/node_modules/react-hook-form/dist/index.esm.mjs ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Controller: () => (/* binding */ Controller),\n/* harmony export */   Form: () => (/* binding */ Form),\n/* harmony export */   FormProvider: () => (/* binding */ FormProvider),\n/* harmony export */   appendErrors: () => (/* binding */ appendErrors),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   useController: () => (/* binding */ useController),\n/* harmony export */   useFieldArray: () => (/* binding */ useFieldArray),\n/* harmony export */   useForm: () => (/* binding */ useForm),\n/* harmony export */   useFormContext: () => (/* binding */ useFormContext),\n/* harmony export */   useFormState: () => (/* binding */ useFormState),\n/* harmony export */   useWatch: () => (/* binding */ useWatch)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nvar isCheckBoxInput = (element)=>element.type === \"checkbox\";\nvar isDateObject = (value1)=>value1 instanceof Date;\nvar isNullOrUndefined = (value1)=>value1 == null;\nconst isObjectType = (value1)=>typeof value1 === \"object\";\nvar isObject = (value1)=>!isNullOrUndefined(value1) && !Array.isArray(value1) && isObjectType(value1) && !isDateObject(value1);\nvar getEventValue = (event)=>isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;\nvar getNodeParentName = (name)=>name.substring(0, name.search(/\\.\\d+(\\.|$)/)) || name;\nvar isNameInFieldArray = (names, name)=>names.has(getNodeParentName(name));\nvar isPlainObject = (tempObject)=>{\n    const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;\n    return isObject(prototypeCopy) && prototypeCopy.hasOwnProperty(\"isPrototypeOf\");\n};\nvar isWeb =  false && 0;\nfunction cloneObject(data) {\n    let copy;\n    const isArray = Array.isArray(data);\n    if (data instanceof Date) {\n        copy = new Date(data);\n    } else if (data instanceof Set) {\n        copy = new Set(data);\n    } else if (!(isWeb && (data instanceof Blob || data instanceof FileList)) && (isArray || isObject(data))) {\n        copy = isArray ? [] : {};\n        if (!isArray && !isPlainObject(data)) {\n            copy = data;\n        } else {\n            for(const key in data){\n                if (data.hasOwnProperty(key)) {\n                    copy[key] = cloneObject(data[key]);\n                }\n            }\n        }\n    } else {\n        return data;\n    }\n    return copy;\n}\nvar compact = (value1)=>Array.isArray(value1) ? value1.filter(Boolean) : [];\nvar isUndefined = (val)=>val === undefined;\nvar get = (object, path, defaultValue)=>{\n    if (!path || !isObject(object)) {\n        return defaultValue;\n    }\n    const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key)=>isNullOrUndefined(result) ? result : result[key], object);\n    return isUndefined(result) || result === object ? isUndefined(object[path]) ? defaultValue : object[path] : result;\n};\nvar isBoolean = (value1)=>typeof value1 === \"boolean\";\nconst EVENTS = {\n    BLUR: \"blur\",\n    FOCUS_OUT: \"focusout\",\n    CHANGE: \"change\"\n};\nconst VALIDATION_MODE = {\n    onBlur: \"onBlur\",\n    onChange: \"onChange\",\n    onSubmit: \"onSubmit\",\n    onTouched: \"onTouched\",\n    all: \"all\"\n};\nconst INPUT_VALIDATION_RULES = {\n    max: \"max\",\n    min: \"min\",\n    maxLength: \"maxLength\",\n    minLength: \"minLength\",\n    pattern: \"pattern\",\n    required: \"required\",\n    validate: \"validate\"\n};\nconst HookFormContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n/**\n * This custom hook allows you to access the form context. useFormContext is intended to be used in deeply nested structures, where it would become inconvenient to pass the context as a prop. To be used with {@link FormProvider}.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)\n *\n * @returns return all useForm methods\n *\n * @example\n * ```tsx\n * function App() {\n *   const methods = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   return (\n *     <FormProvider {...methods} >\n *       <form onSubmit={methods.handleSubmit(onSubmit)}>\n *         <NestedInput />\n *         <input type=\"submit\" />\n *       </form>\n *     </FormProvider>\n *   );\n * }\n *\n *  function NestedInput() {\n *   const { register } = useFormContext(); // retrieve all hook methods\n *   return <input {...register(\"test\")} />;\n * }\n * ```\n */ const useFormContext = ()=>react__WEBPACK_IMPORTED_MODULE_0__.useContext(HookFormContext);\n/**\n * A provider component that propagates the `useForm` methods to all children components via [React Context](https://reactjs.org/docs/context.html) API. To be used with {@link useFormContext}.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)\n *\n * @param props - all useForm methods\n *\n * @example\n * ```tsx\n * function App() {\n *   const methods = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   return (\n *     <FormProvider {...methods} >\n *       <form onSubmit={methods.handleSubmit(onSubmit)}>\n *         <NestedInput />\n *         <input type=\"submit\" />\n *       </form>\n *     </FormProvider>\n *   );\n * }\n *\n *  function NestedInput() {\n *   const { register } = useFormContext(); // retrieve all hook methods\n *   return <input {...register(\"test\")} />;\n * }\n * ```\n */ const FormProvider = (props)=>{\n    const { children, ...data } = props;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(HookFormContext.Provider, {\n        value: data\n    }, children);\n};\nvar getProxyFormState = (formState, control, localProxyFormState, isRoot = true)=>{\n    const result = {\n        defaultValues: control._defaultValues\n    };\n    for(const key in formState){\n        Object.defineProperty(result, key, {\n            get: ()=>{\n                const _key = key;\n                if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {\n                    control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;\n                }\n                localProxyFormState && (localProxyFormState[_key] = true);\n                return formState[_key];\n            }\n        });\n    }\n    return result;\n};\nvar isEmptyObject = (value1)=>isObject(value1) && !Object.keys(value1).length;\nvar shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot)=>{\n    updateFormState(formStateData);\n    const { name, ...formState } = formStateData;\n    return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find((key)=>_proxyFormState[key] === (!isRoot || VALIDATION_MODE.all));\n};\nvar convertToArrayPayload = (value1)=>Array.isArray(value1) ? value1 : [\n        value1\n    ];\nvar shouldSubscribeByName = (name, signalName, exact)=>!name || !signalName || name === signalName || convertToArrayPayload(name).some((currentName)=>currentName && (exact ? currentName === signalName : currentName.startsWith(signalName) || signalName.startsWith(currentName)));\nfunction useSubscribe(props) {\n    const _props = react__WEBPACK_IMPORTED_MODULE_0__.useRef(props);\n    _props.current = props;\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        const subscription = !props.disabled && _props.current.subject && _props.current.subject.subscribe({\n            next: _props.current.next\n        });\n        return ()=>{\n            subscription && subscription.unsubscribe();\n        };\n    }, [\n        props.disabled\n    ]);\n}\n/**\n * This custom hook allows you to subscribe to each form state, and isolate the re-render at the custom hook level. It has its scope in terms of form state subscription, so it would not affect other useFormState and useForm. Using this hook can reduce the re-render impact on large and complex form application.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformstate) • [Demo](https://codesandbox.io/s/useformstate-75xly)\n *\n * @param props - include options on specify fields to subscribe. {@link UseFormStateReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, handleSubmit, control } = useForm({\n *     defaultValues: {\n *     firstName: \"firstName\"\n *   }});\n *   const { dirtyFields } = useFormState({\n *     control\n *   });\n *   const onSubmit = (data) => console.log(data);\n *\n *   return (\n *     <form onSubmit={handleSubmit(onSubmit)}>\n *       <input {...register(\"firstName\")} placeholder=\"First Name\" />\n *       {dirtyFields.firstName && <p>Field is dirty.</p>}\n *       <input type=\"submit\" />\n *     </form>\n *   );\n * }\n * ```\n */ function useFormState(props) {\n    const methods = useFormContext();\n    const { control = methods.control, disabled, name, exact } = props || {};\n    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(control._formState);\n    const _mounted = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    const _localProxyFormState = react__WEBPACK_IMPORTED_MODULE_0__.useRef({\n        isDirty: false,\n        isLoading: false,\n        dirtyFields: false,\n        touchedFields: false,\n        isValidating: false,\n        isValid: false,\n        errors: false\n    });\n    const _name = react__WEBPACK_IMPORTED_MODULE_0__.useRef(name);\n    _name.current = name;\n    useSubscribe({\n        disabled,\n        next: (value1)=>_mounted.current && shouldSubscribeByName(_name.current, value1.name, exact) && shouldRenderFormState(value1, _localProxyFormState.current, control._updateFormState) && updateFormState({\n                ...control._formState,\n                ...value1\n            }),\n        subject: control._subjects.state\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        _mounted.current = true;\n        _localProxyFormState.current.isValid && control._updateValid(true);\n        return ()=>{\n            _mounted.current = false;\n        };\n    }, [\n        control\n    ]);\n    return getProxyFormState(formState, control, _localProxyFormState.current, false);\n}\nvar isString = (value1)=>typeof value1 === \"string\";\nvar generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue)=>{\n    if (isString(names)) {\n        isGlobal && _names.watch.add(names);\n        return get(formValues, names, defaultValue);\n    }\n    if (Array.isArray(names)) {\n        return names.map((fieldName)=>(isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));\n    }\n    isGlobal && (_names.watchAll = true);\n    return formValues;\n};\n/**\n * Custom hook to subscribe to field change and isolate re-rendering at the component level.\n *\n * @remarks\n *\n * [API](https://react-hook-form.com/docs/usewatch) • [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)\n *\n * @example\n * ```tsx\n * const { control } = useForm();\n * const values = useWatch({\n *   name: \"fieldName\"\n *   control,\n * })\n * ```\n */ function useWatch(props) {\n    const methods = useFormContext();\n    const { control = methods.control, name, defaultValue, disabled, exact } = props || {};\n    const _name = react__WEBPACK_IMPORTED_MODULE_0__.useRef(name);\n    _name.current = name;\n    useSubscribe({\n        disabled,\n        subject: control._subjects.values,\n        next: (formState)=>{\n            if (shouldSubscribeByName(_name.current, formState.name, exact)) {\n                updateValue(cloneObject(generateWatchOutput(_name.current, control._names, formState.values || control._formValues, false, defaultValue)));\n            }\n        }\n    });\n    const [value1, updateValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(control._getWatch(name, defaultValue));\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>control._removeUnmounted());\n    return value1;\n}\nvar isKey = (value1)=>/^\\w*$/.test(value1);\nvar stringToPath = (input)=>compact(input.replace(/[\"|']|\\]/g, \"\").split(/\\.|\\[/));\nvar set = (object, path, value1)=>{\n    let index = -1;\n    const tempPath = isKey(path) ? [\n        path\n    ] : stringToPath(path);\n    const length = tempPath.length;\n    const lastIndex = length - 1;\n    while(++index < length){\n        const key = tempPath[index];\n        let newValue = value1;\n        if (index !== lastIndex) {\n            const objValue = object[key];\n            newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};\n        }\n        object[key] = newValue;\n        object = object[key];\n    }\n    return object;\n};\n/**\n * Custom hook to work with controlled component, this function provide you with both form and field level state. Re-render is isolated at the hook level.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usecontroller) • [Demo](https://codesandbox.io/s/usecontroller-0o8px)\n *\n * @param props - the path name to the form field value, and validation rules.\n *\n * @returns field properties, field and form state. {@link UseControllerReturn}\n *\n * @example\n * ```tsx\n * function Input(props) {\n *   const { field, fieldState, formState } = useController(props);\n *   return (\n *     <div>\n *       <input {...field} placeholder={props.name} />\n *       <p>{fieldState.isTouched && \"Touched\"}</p>\n *       <p>{formState.isSubmitted ? \"submitted\" : \"\"}</p>\n *     </div>\n *   );\n * }\n * ```\n */ function useController(props) {\n    const methods = useFormContext();\n    const { name, disabled, control = methods.control, shouldUnregister } = props;\n    const isArrayField = isNameInFieldArray(control._names.array, name);\n    const value1 = useWatch({\n        control,\n        name,\n        defaultValue: get(control._formValues, name, get(control._defaultValues, name, props.defaultValue)),\n        exact: true\n    });\n    const formState = useFormState({\n        control,\n        name\n    });\n    const _registerProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(control.register(name, {\n        ...props.rules,\n        value: value1,\n        ...isBoolean(props.disabled) ? {\n            disabled: props.disabled\n        } : {}\n    }));\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;\n        const updateMounted = (name, value1)=>{\n            const field = get(control._fields, name);\n            if (field) {\n                field._f.mount = value1;\n            }\n        };\n        updateMounted(name, true);\n        if (_shouldUnregisterField) {\n            const value1 = cloneObject(get(control._options.defaultValues, name));\n            set(control._defaultValues, name, value1);\n            if (isUndefined(get(control._formValues, name))) {\n                set(control._formValues, name, value1);\n            }\n        }\n        return ()=>{\n            (isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);\n        };\n    }, [\n        name,\n        control,\n        isArrayField,\n        shouldUnregister\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (get(control._fields, name)) {\n            control._updateDisabledField({\n                disabled,\n                fields: control._fields,\n                name,\n                value: get(control._fields, name)._f.value\n            });\n        }\n    }, [\n        disabled,\n        name,\n        control\n    ]);\n    return {\n        field: {\n            name,\n            value: value1,\n            ...isBoolean(disabled) || formState.disabled ? {\n                disabled: formState.disabled || disabled\n            } : {},\n            onChange: react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event)=>_registerProps.current.onChange({\n                    target: {\n                        value: getEventValue(event),\n                        name: name\n                    },\n                    type: EVENTS.CHANGE\n                }), [\n                name\n            ]),\n            onBlur: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>_registerProps.current.onBlur({\n                    target: {\n                        value: get(control._formValues, name),\n                        name: name\n                    },\n                    type: EVENTS.BLUR\n                }), [\n                name,\n                control\n            ]),\n            ref: (elm)=>{\n                const field = get(control._fields, name);\n                if (field && elm) {\n                    field._f.ref = {\n                        focus: ()=>elm.focus(),\n                        select: ()=>elm.select(),\n                        setCustomValidity: (message)=>elm.setCustomValidity(message),\n                        reportValidity: ()=>elm.reportValidity()\n                    };\n                }\n            }\n        },\n        formState,\n        fieldState: Object.defineProperties({}, {\n            invalid: {\n                enumerable: true,\n                get: ()=>!!get(formState.errors, name)\n            },\n            isDirty: {\n                enumerable: true,\n                get: ()=>!!get(formState.dirtyFields, name)\n            },\n            isTouched: {\n                enumerable: true,\n                get: ()=>!!get(formState.touchedFields, name)\n            },\n            error: {\n                enumerable: true,\n                get: ()=>get(formState.errors, name)\n            }\n        })\n    };\n}\n/**\n * Component based on `useController` hook to work with controlled component.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usecontroller/controller) • [Demo](https://codesandbox.io/s/react-hook-form-v6-controller-ts-jwyzw) • [Video](https://www.youtube.com/watch?v=N2UNk_UCVyA)\n *\n * @param props - the path name to the form field value, and validation rules.\n *\n * @returns provide field handler functions, field and form state.\n *\n * @example\n * ```tsx\n * function App() {\n *   const { control } = useForm<FormValues>({\n *     defaultValues: {\n *       test: \"\"\n *     }\n *   });\n *\n *   return (\n *     <form>\n *       <Controller\n *         control={control}\n *         name=\"test\"\n *         render={({ field: { onChange, onBlur, value, ref }, formState, fieldState }) => (\n *           <>\n *             <input\n *               onChange={onChange} // send value to hook form\n *               onBlur={onBlur} // notify when input is touched\n *               value={value} // return updated value\n *               ref={ref} // set ref for focus management\n *             />\n *             <p>{formState.isSubmitted ? \"submitted\" : \"\"}</p>\n *             <p>{fieldState.isTouched ? \"touched\" : \"\"}</p>\n *           </>\n *         )}\n *       />\n *     </form>\n *   );\n * }\n * ```\n */ const Controller = (props)=>props.render(useController(props));\nconst POST_REQUEST = \"post\";\n/**\n * Form component to manage submission.\n *\n * @param props - to setup submission detail. {@link FormProps}\n *\n * @returns form component or headless render prop.\n *\n * @example\n * ```tsx\n * function App() {\n *   const { control, formState: { errors } } = useForm();\n *\n *   return (\n *     <Form action=\"/api\" control={control}>\n *       <input {...register(\"name\")} />\n *       <p>{errors?.root?.server && 'Server error'}</p>\n *       <button>Submit</button>\n *     </Form>\n *   );\n * }\n * ```\n */ function Form(props) {\n    const methods = useFormContext();\n    const [mounted, setMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const { control = methods.control, onSubmit, children, action, method = POST_REQUEST, headers, encType, onError, render, onSuccess, validateStatus, ...rest } = props;\n    const submit = async (event)=>{\n        let hasError = false;\n        let type = \"\";\n        await control.handleSubmit(async (data)=>{\n            const formData = new FormData();\n            let formDataJson = \"\";\n            try {\n                formDataJson = JSON.stringify(data);\n            } catch (_a) {}\n            for (const name of control._names.mount){\n                formData.append(name, get(data, name));\n            }\n            if (onSubmit) {\n                await onSubmit({\n                    data,\n                    event,\n                    method,\n                    formData,\n                    formDataJson\n                });\n            }\n            if (action) {\n                try {\n                    const shouldStringifySubmissionData = [\n                        headers && headers[\"Content-Type\"],\n                        encType\n                    ].some((value1)=>value1 && value1.includes(\"json\"));\n                    const response = await fetch(action, {\n                        method,\n                        headers: {\n                            ...headers,\n                            ...encType ? {\n                                \"Content-Type\": encType\n                            } : {}\n                        },\n                        body: shouldStringifySubmissionData ? formDataJson : formData\n                    });\n                    if (response && (validateStatus ? !validateStatus(response.status) : response.status < 200 || response.status >= 300)) {\n                        hasError = true;\n                        onError && onError({\n                            response\n                        });\n                        type = String(response.status);\n                    } else {\n                        onSuccess && onSuccess({\n                            response\n                        });\n                    }\n                } catch (error) {\n                    hasError = true;\n                    onError && onError({\n                        error\n                    });\n                }\n            }\n        })(event);\n        if (hasError && props.control) {\n            props.control._subjects.state.next({\n                isSubmitSuccessful: false\n            });\n            props.control.setError(\"root.server\", {\n                type\n            });\n        }\n    };\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        setMounted(true);\n    }, []);\n    return render ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, render({\n        submit\n    })) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"form\", {\n        noValidate: mounted,\n        action: action,\n        method: method,\n        encType: encType,\n        onSubmit: submit,\n        ...rest\n    }, children);\n}\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message)=>validateAllFieldCriteria ? {\n        ...errors[name],\n        types: {\n            ...errors[name] && errors[name].types ? errors[name].types : {},\n            [type]: message || true\n        }\n    } : {};\nvar generateId = ()=>{\n    const d = typeof performance === \"undefined\" ? Date.now() : performance.now() * 1000;\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c)=>{\n        const r = (Math.random() * 16 + d) % 16 | 0;\n        return (c == \"x\" ? r : r & 0x3 | 0x8).toString(16);\n    });\n};\nvar getFocusFieldName = (name, index, options = {})=>options.shouldFocus || isUndefined(options.shouldFocus) ? options.focusName || `${name}.${isUndefined(options.focusIndex) ? index : options.focusIndex}.` : \"\";\nvar getValidationModes = (mode)=>({\n        isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n        isOnBlur: mode === VALIDATION_MODE.onBlur,\n        isOnChange: mode === VALIDATION_MODE.onChange,\n        isOnAll: mode === VALIDATION_MODE.all,\n        isOnTouch: mode === VALIDATION_MODE.onTouched\n    });\nvar isWatched = (name, _names, isBlurEvent)=>!isBlurEvent && (_names.watchAll || _names.watch.has(name) || [\n        ..._names.watch\n    ].some((watchName)=>name.startsWith(watchName) && /^\\.\\w+/.test(name.slice(watchName.length))));\nconst iterateFieldsByAction = (fields, action, fieldsNames, abortEarly)=>{\n    for (const key of fieldsNames || Object.keys(fields)){\n        const field = get(fields, key);\n        if (field) {\n            const { _f, ...currentField } = field;\n            if (_f) {\n                if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) {\n                    break;\n                } else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {\n                    break;\n                } else {\n                    iterateFieldsByAction(currentField, action);\n                }\n            } else if (isObject(currentField)) {\n                iterateFieldsByAction(currentField, action);\n            }\n        }\n    }\n};\nvar updateFieldArrayRootError = (errors, error, name)=>{\n    const fieldArrayErrors = compact(get(errors, name));\n    set(fieldArrayErrors, \"root\", error[name]);\n    set(errors, name, fieldArrayErrors);\n    return errors;\n};\nvar isFileInput = (element)=>element.type === \"file\";\nvar isFunction = (value1)=>typeof value1 === \"function\";\nvar isHTMLElement = (value1)=>{\n    if (!isWeb) {\n        return false;\n    }\n    const owner = value1 ? value1.ownerDocument : 0;\n    return value1 instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);\n};\nvar isMessage = (value1)=>isString(value1);\nvar isRadioInput = (element)=>element.type === \"radio\";\nvar isRegex = (value1)=>value1 instanceof RegExp;\nconst defaultResult = {\n    value: false,\n    isValid: false\n};\nconst validResult = {\n    value: true,\n    isValid: true\n};\nvar getCheckboxValue = (options)=>{\n    if (Array.isArray(options)) {\n        if (options.length > 1) {\n            const values = options.filter((option)=>option && option.checked && !option.disabled).map((option)=>option.value);\n            return {\n                value: values,\n                isValid: !!values.length\n            };\n        }\n        return options[0].checked && !options[0].disabled ? options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === \"\" ? validResult : {\n            value: options[0].value,\n            isValid: true\n        } : validResult : defaultResult;\n    }\n    return defaultResult;\n};\nconst defaultReturn = {\n    isValid: false,\n    value: null\n};\nvar getRadioValue = (options)=>Array.isArray(options) ? options.reduce((previous, option)=>option && option.checked && !option.disabled ? {\n            isValid: true,\n            value: option.value\n        } : previous, defaultReturn) : defaultReturn;\nfunction getValidateError(result, ref, type = \"validate\") {\n    if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean(result) && !result) {\n        return {\n            type,\n            message: isMessage(result) ? result : \"\",\n            ref\n        };\n    }\n}\nvar getValueAndMessage = (validationData)=>isObject(validationData) && !isRegex(validationData) ? validationData : {\n        value: validationData,\n        message: \"\"\n    };\nvar validateField = async (field, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray)=>{\n    const { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, valueAsNumber, mount, disabled } = field._f;\n    const inputValue = get(formValues, name);\n    if (!mount || disabled) {\n        return {};\n    }\n    const inputRef = refs ? refs[0] : ref;\n    const setCustomValidity = (message)=>{\n        if (shouldUseNativeValidation && inputRef.reportValidity) {\n            inputRef.setCustomValidity(isBoolean(message) ? \"\" : message || \"\");\n            inputRef.reportValidity();\n        }\n    };\n    const error = {};\n    const isRadio = isRadioInput(ref);\n    const isCheckBox = isCheckBoxInput(ref);\n    const isRadioOrCheckbox = isRadio || isCheckBox;\n    const isEmpty = (valueAsNumber || isFileInput(ref)) && isUndefined(ref.value) && isUndefined(inputValue) || isHTMLElement(ref) && ref.value === \"\" || inputValue === \"\" || Array.isArray(inputValue) && !inputValue.length;\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength)=>{\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\n        error[name] = {\n            type: exceedMax ? maxType : minType,\n            message,\n            ref,\n            ...appendErrorsCurry(exceedMax ? maxType : minType, message)\n        };\n    };\n    if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required && (!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {\n        const { value: value1, message } = isMessage(required) ? {\n            value: !!required,\n            message: required\n        } : getValueAndMessage(required);\n        if (value1) {\n            error[name] = {\n                type: INPUT_VALIDATION_RULES.required,\n                message,\n                ref: inputRef,\n                ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message)\n            };\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(message);\n                return error;\n            }\n        }\n    }\n    if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {\n        let exceedMax;\n        let exceedMin;\n        const maxOutput = getValueAndMessage(max);\n        const minOutput = getValueAndMessage(min);\n        if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {\n            const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);\n            if (!isNullOrUndefined(maxOutput.value)) {\n                exceedMax = valueNumber > maxOutput.value;\n            }\n            if (!isNullOrUndefined(minOutput.value)) {\n                exceedMin = valueNumber < minOutput.value;\n            }\n        } else {\n            const valueDate = ref.valueAsDate || new Date(inputValue);\n            const convertTimeToDate = (time)=>new Date(new Date().toDateString() + \" \" + time);\n            const isTime = ref.type == \"time\";\n            const isWeek = ref.type == \"week\";\n            if (isString(maxOutput.value) && inputValue) {\n                exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);\n            }\n            if (isString(minOutput.value) && inputValue) {\n                exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);\n            }\n        }\n        if (exceedMax || exceedMin) {\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(error[name].message);\n                return error;\n            }\n        }\n    }\n    if ((maxLength || minLength) && !isEmpty && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {\n        const maxLengthOutput = getValueAndMessage(maxLength);\n        const minLengthOutput = getValueAndMessage(minLength);\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;\n        if (exceedMax || exceedMin) {\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(error[name].message);\n                return error;\n            }\n        }\n    }\n    if (pattern && !isEmpty && isString(inputValue)) {\n        const { value: patternValue, message } = getValueAndMessage(pattern);\n        if (isRegex(patternValue) && !inputValue.match(patternValue)) {\n            error[name] = {\n                type: INPUT_VALIDATION_RULES.pattern,\n                message,\n                ref,\n                ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message)\n            };\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(message);\n                return error;\n            }\n        }\n    }\n    if (validate) {\n        if (isFunction(validate)) {\n            const result = await validate(inputValue, formValues);\n            const validateError = getValidateError(result, inputRef);\n            if (validateError) {\n                error[name] = {\n                    ...validateError,\n                    ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message)\n                };\n                if (!validateAllFieldCriteria) {\n                    setCustomValidity(validateError.message);\n                    return error;\n                }\n            }\n        } else if (isObject(validate)) {\n            let validationResult = {};\n            for(const key in validate){\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n                    break;\n                }\n                const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);\n                if (validateError) {\n                    validationResult = {\n                        ...validateError,\n                        ...appendErrorsCurry(key, validateError.message)\n                    };\n                    setCustomValidity(validateError.message);\n                    if (validateAllFieldCriteria) {\n                        error[name] = validationResult;\n                    }\n                }\n            }\n            if (!isEmptyObject(validationResult)) {\n                error[name] = {\n                    ref: inputRef,\n                    ...validationResult\n                };\n                if (!validateAllFieldCriteria) {\n                    return error;\n                }\n            }\n        }\n    }\n    setCustomValidity(true);\n    return error;\n};\nvar appendAt = (data, value1)=>[\n        ...data,\n        ...convertToArrayPayload(value1)\n    ];\nvar fillEmptyArray = (value1)=>Array.isArray(value1) ? value1.map(()=>undefined) : undefined;\nfunction insert(data, index, value1) {\n    return [\n        ...data.slice(0, index),\n        ...convertToArrayPayload(value1),\n        ...data.slice(index)\n    ];\n}\nvar moveArrayAt = (data, from, to)=>{\n    if (!Array.isArray(data)) {\n        return [];\n    }\n    if (isUndefined(data[to])) {\n        data[to] = undefined;\n    }\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n};\nvar prependAt = (data, value1)=>[\n        ...convertToArrayPayload(value1),\n        ...convertToArrayPayload(data)\n    ];\nfunction removeAtIndexes(data, indexes) {\n    let i = 0;\n    const temp = [\n        ...data\n    ];\n    for (const index of indexes){\n        temp.splice(index - i, 1);\n        i++;\n    }\n    return compact(temp).length ? temp : [];\n}\nvar removeArrayAt = (data, index)=>isUndefined(index) ? [] : removeAtIndexes(data, convertToArrayPayload(index).sort((a, b)=>a - b));\nvar swapArrayAt = (data, indexA, indexB)=>{\n    [data[indexA], data[indexB]] = [\n        data[indexB],\n        data[indexA]\n    ];\n};\nfunction baseGet(object, updatePath) {\n    const length = updatePath.slice(0, -1).length;\n    let index = 0;\n    while(index < length){\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\n    }\n    return object;\n}\nfunction isEmptyArray(obj) {\n    for(const key in obj){\n        if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction unset(object, path) {\n    const paths = Array.isArray(path) ? path : isKey(path) ? [\n        path\n    ] : stringToPath(path);\n    const childObject = paths.length === 1 ? object : baseGet(object, paths);\n    const index = paths.length - 1;\n    const key = paths[index];\n    if (childObject) {\n        delete childObject[key];\n    }\n    if (index !== 0 && (isObject(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {\n        unset(object, paths.slice(0, -1));\n    }\n    return object;\n}\nvar updateAt = (fieldValues, index, value1)=>{\n    fieldValues[index] = value1;\n    return fieldValues;\n};\n/**\n * A custom hook that exposes convenient methods to perform operations with a list of dynamic inputs that need to be appended, updated, removed etc. • [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn) • [Video](https://youtu.be/4MrbfGSFY2A)\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usefieldarray) • [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn)\n *\n * @param props - useFieldArray props\n *\n * @returns methods - functions to manipulate with the Field Arrays (dynamic inputs) {@link UseFieldArrayReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, control, handleSubmit, reset, trigger, setError } = useForm({\n *     defaultValues: {\n *       test: []\n *     }\n *   });\n *   const { fields, append } = useFieldArray({\n *     control,\n *     name: \"test\"\n *   });\n *\n *   return (\n *     <form onSubmit={handleSubmit(data => console.log(data))}>\n *       {fields.map((item, index) => (\n *          <input key={item.id} {...register(`test.${index}.firstName`)}  />\n *       ))}\n *       <button type=\"button\" onClick={() => append({ firstName: \"bill\" })}>\n *         append\n *       </button>\n *       <input type=\"submit\" />\n *     </form>\n *   );\n * }\n * ```\n */ function useFieldArray(props) {\n    const methods = useFormContext();\n    const { control = methods.control, name, keyName = \"id\", shouldUnregister } = props;\n    const [fields, setFields] = react__WEBPACK_IMPORTED_MODULE_0__.useState(control._getFieldArray(name));\n    const ids = react__WEBPACK_IMPORTED_MODULE_0__.useRef(control._getFieldArray(name).map(generateId));\n    const _fieldIds = react__WEBPACK_IMPORTED_MODULE_0__.useRef(fields);\n    const _name = react__WEBPACK_IMPORTED_MODULE_0__.useRef(name);\n    const _actioned = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    _name.current = name;\n    _fieldIds.current = fields;\n    control._names.array.add(name);\n    props.rules && control.register(name, props.rules);\n    useSubscribe({\n        next: ({ values, name: fieldArrayName })=>{\n            if (fieldArrayName === _name.current || !fieldArrayName) {\n                const fieldValues = get(values, _name.current);\n                if (Array.isArray(fieldValues)) {\n                    setFields(fieldValues);\n                    ids.current = fieldValues.map(generateId);\n                }\n            }\n        },\n        subject: control._subjects.array\n    });\n    const updateValues = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((updatedFieldArrayValues)=>{\n        _actioned.current = true;\n        control._updateFieldArray(name, updatedFieldArrayValues);\n    }, [\n        control,\n        name\n    ]);\n    const append = (value1, options)=>{\n        const appendValue = convertToArrayPayload(cloneObject(value1));\n        const updatedFieldArrayValues = appendAt(control._getFieldArray(name), appendValue);\n        control._names.focus = getFocusFieldName(name, updatedFieldArrayValues.length - 1, options);\n        ids.current = appendAt(ids.current, appendValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._updateFieldArray(name, updatedFieldArrayValues, appendAt, {\n            argA: fillEmptyArray(value1)\n        });\n    };\n    const prepend = (value1, options)=>{\n        const prependValue = convertToArrayPayload(cloneObject(value1));\n        const updatedFieldArrayValues = prependAt(control._getFieldArray(name), prependValue);\n        control._names.focus = getFocusFieldName(name, 0, options);\n        ids.current = prependAt(ids.current, prependValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._updateFieldArray(name, updatedFieldArrayValues, prependAt, {\n            argA: fillEmptyArray(value1)\n        });\n    };\n    const remove = (index)=>{\n        const updatedFieldArrayValues = removeArrayAt(control._getFieldArray(name), index);\n        ids.current = removeArrayAt(ids.current, index);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._updateFieldArray(name, updatedFieldArrayValues, removeArrayAt, {\n            argA: index\n        });\n    };\n    const insert$1 = (index, value1, options)=>{\n        const insertValue = convertToArrayPayload(cloneObject(value1));\n        const updatedFieldArrayValues = insert(control._getFieldArray(name), index, insertValue);\n        control._names.focus = getFocusFieldName(name, index, options);\n        ids.current = insert(ids.current, index, insertValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._updateFieldArray(name, updatedFieldArrayValues, insert, {\n            argA: index,\n            argB: fillEmptyArray(value1)\n        });\n    };\n    const swap = (indexA, indexB)=>{\n        const updatedFieldArrayValues = control._getFieldArray(name);\n        swapArrayAt(updatedFieldArrayValues, indexA, indexB);\n        swapArrayAt(ids.current, indexA, indexB);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._updateFieldArray(name, updatedFieldArrayValues, swapArrayAt, {\n            argA: indexA,\n            argB: indexB\n        }, false);\n    };\n    const move = (from, to)=>{\n        const updatedFieldArrayValues = control._getFieldArray(name);\n        moveArrayAt(updatedFieldArrayValues, from, to);\n        moveArrayAt(ids.current, from, to);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._updateFieldArray(name, updatedFieldArrayValues, moveArrayAt, {\n            argA: from,\n            argB: to\n        }, false);\n    };\n    const update = (index, value1)=>{\n        const updateValue = cloneObject(value1);\n        const updatedFieldArrayValues = updateAt(control._getFieldArray(name), index, updateValue);\n        ids.current = [\n            ...updatedFieldArrayValues\n        ].map((item, i)=>!item || i === index ? generateId() : ids.current[i]);\n        updateValues(updatedFieldArrayValues);\n        setFields([\n            ...updatedFieldArrayValues\n        ]);\n        control._updateFieldArray(name, updatedFieldArrayValues, updateAt, {\n            argA: index,\n            argB: updateValue\n        }, true, false);\n    };\n    const replace = (value1)=>{\n        const updatedFieldArrayValues = convertToArrayPayload(cloneObject(value1));\n        ids.current = updatedFieldArrayValues.map(generateId);\n        updateValues([\n            ...updatedFieldArrayValues\n        ]);\n        setFields([\n            ...updatedFieldArrayValues\n        ]);\n        control._updateFieldArray(name, [\n            ...updatedFieldArrayValues\n        ], (data)=>data, {}, true, false);\n    };\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        control._state.action = false;\n        isWatched(name, control._names) && control._subjects.state.next({\n            ...control._formState\n        });\n        if (_actioned.current && (!getValidationModes(control._options.mode).isOnSubmit || control._formState.isSubmitted)) {\n            if (control._options.resolver) {\n                control._executeSchema([\n                    name\n                ]).then((result)=>{\n                    const error = get(result.errors, name);\n                    const existingError = get(control._formState.errors, name);\n                    if (existingError ? !error && existingError.type || error && (existingError.type !== error.type || existingError.message !== error.message) : error && error.type) {\n                        error ? set(control._formState.errors, name, error) : unset(control._formState.errors, name);\n                        control._subjects.state.next({\n                            errors: control._formState.errors\n                        });\n                    }\n                });\n            } else {\n                const field = get(control._fields, name);\n                if (field && field._f && !(getValidationModes(control._options.reValidateMode).isOnSubmit && getValidationModes(control._options.mode).isOnSubmit)) {\n                    validateField(field, control._formValues, control._options.criteriaMode === VALIDATION_MODE.all, control._options.shouldUseNativeValidation, true).then((error)=>!isEmptyObject(error) && control._subjects.state.next({\n                            errors: updateFieldArrayRootError(control._formState.errors, error, name)\n                        }));\n                }\n            }\n        }\n        control._subjects.values.next({\n            name,\n            values: {\n                ...control._formValues\n            }\n        });\n        control._names.focus && iterateFieldsByAction(control._fields, (ref, key)=>{\n            if (control._names.focus && key.startsWith(control._names.focus) && ref.focus) {\n                ref.focus();\n                return 1;\n            }\n            return;\n        });\n        control._names.focus = \"\";\n        control._updateValid();\n        _actioned.current = false;\n    }, [\n        fields,\n        name,\n        control\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        !get(control._formValues, name) && control._updateFieldArray(name);\n        return ()=>{\n            (control._options.shouldUnregister || shouldUnregister) && control.unregister(name);\n        };\n    }, [\n        name,\n        control,\n        keyName,\n        shouldUnregister\n    ]);\n    return {\n        swap: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(swap, [\n            updateValues,\n            name,\n            control\n        ]),\n        move: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(move, [\n            updateValues,\n            name,\n            control\n        ]),\n        prepend: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(prepend, [\n            updateValues,\n            name,\n            control\n        ]),\n        append: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(append, [\n            updateValues,\n            name,\n            control\n        ]),\n        remove: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(remove, [\n            updateValues,\n            name,\n            control\n        ]),\n        insert: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(insert$1, [\n            updateValues,\n            name,\n            control\n        ]),\n        update: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(update, [\n            updateValues,\n            name,\n            control\n        ]),\n        replace: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(replace, [\n            updateValues,\n            name,\n            control\n        ]),\n        fields: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>fields.map((field, index)=>({\n                    ...field,\n                    [keyName]: ids.current[index] || generateId()\n                })), [\n            fields,\n            keyName\n        ])\n    };\n}\nvar createSubject = ()=>{\n    let _observers = [];\n    const next = (value1)=>{\n        for (const observer of _observers){\n            observer.next && observer.next(value1);\n        }\n    };\n    const subscribe = (observer)=>{\n        _observers.push(observer);\n        return {\n            unsubscribe: ()=>{\n                _observers = _observers.filter((o)=>o !== observer);\n            }\n        };\n    };\n    const unsubscribe = ()=>{\n        _observers = [];\n    };\n    return {\n        get observers () {\n            return _observers;\n        },\n        next,\n        subscribe,\n        unsubscribe\n    };\n};\nvar isPrimitive = (value1)=>isNullOrUndefined(value1) || !isObjectType(value1);\nfunction deepEqual(object1, object2) {\n    if (isPrimitive(object1) || isPrimitive(object2)) {\n        return object1 === object2;\n    }\n    if (isDateObject(object1) && isDateObject(object2)) {\n        return object1.getTime() === object2.getTime();\n    }\n    const keys1 = Object.keys(object1);\n    const keys2 = Object.keys(object2);\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1){\n        const val1 = object1[key];\n        if (!keys2.includes(key)) {\n            return false;\n        }\n        if (key !== \"ref\") {\n            const val2 = object2[key];\n            if (isDateObject(val1) && isDateObject(val2) || isObject(val1) && isObject(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual(val1, val2) : val1 !== val2) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nvar isMultipleSelect = (element)=>element.type === `select-multiple`;\nvar isRadioOrCheckbox = (ref)=>isRadioInput(ref) || isCheckBoxInput(ref);\nvar live = (ref)=>isHTMLElement(ref) && ref.isConnected;\nvar objectHasFunction = (data)=>{\n    for(const key in data){\n        if (isFunction(data[key])) {\n            return true;\n        }\n    }\n    return false;\n};\nfunction markFieldsDirty(data, fields = {}) {\n    const isParentNodeArray = Array.isArray(data);\n    if (isObject(data) || isParentNodeArray) {\n        for(const key in data){\n            if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {\n                fields[key] = Array.isArray(data[key]) ? [] : {};\n                markFieldsDirty(data[key], fields[key]);\n            } else if (!isNullOrUndefined(data[key])) {\n                fields[key] = true;\n            }\n        }\n    }\n    return fields;\n}\nfunction getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {\n    const isParentNodeArray = Array.isArray(data);\n    if (isObject(data) || isParentNodeArray) {\n        for(const key in data){\n            if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {\n                if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key])) {\n                    dirtyFieldsFromValues[key] = Array.isArray(data[key]) ? markFieldsDirty(data[key], []) : {\n                        ...markFieldsDirty(data[key])\n                    };\n                } else {\n                    getDirtyFieldsFromDefaultValues(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);\n                }\n            } else {\n                dirtyFieldsFromValues[key] = !deepEqual(data[key], formValues[key]);\n            }\n        }\n    }\n    return dirtyFieldsFromValues;\n}\nvar getDirtyFields = (defaultValues, formValues)=>getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));\nvar getFieldValueAs = (value1, { valueAsNumber, valueAsDate, setValueAs })=>isUndefined(value1) ? value1 : valueAsNumber ? value1 === \"\" ? NaN : value1 ? +value1 : value1 : valueAsDate && isString(value1) ? new Date(value1) : setValueAs ? setValueAs(value1) : value1;\nfunction getFieldValue(_f) {\n    const ref = _f.ref;\n    if (_f.refs ? _f.refs.every((ref)=>ref.disabled) : ref.disabled) {\n        return;\n    }\n    if (isFileInput(ref)) {\n        return ref.files;\n    }\n    if (isRadioInput(ref)) {\n        return getRadioValue(_f.refs).value;\n    }\n    if (isMultipleSelect(ref)) {\n        return [\n            ...ref.selectedOptions\n        ].map(({ value: value1 })=>value1);\n    }\n    if (isCheckBoxInput(ref)) {\n        return getCheckboxValue(_f.refs).value;\n    }\n    return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);\n}\nvar getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation)=>{\n    const fields = {};\n    for (const name of fieldsNames){\n        const field = get(_fields, name);\n        field && set(fields, name, field._f);\n    }\n    return {\n        criteriaMode,\n        names: [\n            ...fieldsNames\n        ],\n        fields,\n        shouldUseNativeValidation\n    };\n};\nvar getRuleValue = (rule)=>isUndefined(rule) ? rule : isRegex(rule) ? rule.source : isObject(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;\nvar hasValidation = (options)=>options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);\nfunction schemaErrorLookup(errors, _fields, name) {\n    const error = get(errors, name);\n    if (error || isKey(name)) {\n        return {\n            error,\n            name\n        };\n    }\n    const names = name.split(\".\");\n    while(names.length){\n        const fieldName = names.join(\".\");\n        const field = get(_fields, fieldName);\n        const foundError = get(errors, fieldName);\n        if (field && !Array.isArray(field) && name !== fieldName) {\n            return {\n                name\n            };\n        }\n        if (foundError && foundError.type) {\n            return {\n                name: fieldName,\n                error: foundError\n            };\n        }\n        names.pop();\n    }\n    return {\n        name\n    };\n}\nvar skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode)=>{\n    if (mode.isOnAll) {\n        return false;\n    } else if (!isSubmitted && mode.isOnTouch) {\n        return !(isTouched || isBlurEvent);\n    } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {\n        return !isBlurEvent;\n    } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {\n        return isBlurEvent;\n    }\n    return true;\n};\nvar unsetEmptyArray = (ref, name)=>!compact(get(ref, name)).length && unset(ref, name);\nconst defaultOptions = {\n    mode: VALIDATION_MODE.onSubmit,\n    reValidateMode: VALIDATION_MODE.onChange,\n    shouldFocusError: true\n};\nfunction createFormControl(props = {}, flushRootRender) {\n    let _options = {\n        ...defaultOptions,\n        ...props\n    };\n    let _formState = {\n        submitCount: 0,\n        isDirty: false,\n        isLoading: isFunction(_options.defaultValues),\n        isValidating: false,\n        isSubmitted: false,\n        isSubmitting: false,\n        isSubmitSuccessful: false,\n        isValid: false,\n        touchedFields: {},\n        dirtyFields: {},\n        errors: _options.errors || {},\n        disabled: _options.disabled || false\n    };\n    let _fields = {};\n    let _defaultValues = isObject(_options.values) || isObject(_options.defaultValues) ? cloneObject(_options.values || _options.defaultValues) || {} : {};\n    let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);\n    let _state = {\n        action: false,\n        mount: false,\n        watch: false\n    };\n    let _names = {\n        mount: new Set(),\n        unMount: new Set(),\n        array: new Set(),\n        watch: new Set()\n    };\n    let delayErrorCallback;\n    let timer = 0;\n    const _proxyFormState = {\n        isDirty: false,\n        dirtyFields: false,\n        touchedFields: false,\n        isValidating: false,\n        isValid: false,\n        errors: false\n    };\n    const _subjects = {\n        values: createSubject(),\n        array: createSubject(),\n        state: createSubject()\n    };\n    const validationModeBeforeSubmit = getValidationModes(_options.mode);\n    const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);\n    const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;\n    const debounce = (callback)=>(wait)=>{\n            clearTimeout(timer);\n            timer = setTimeout(callback, wait);\n        };\n    const _updateValid = async (shouldUpdateValid)=>{\n        if (_proxyFormState.isValid || shouldUpdateValid) {\n            const isValid = _options.resolver ? isEmptyObject((await _executeSchema()).errors) : await executeBuiltInValidation(_fields, true);\n            if (isValid !== _formState.isValid) {\n                _subjects.state.next({\n                    isValid\n                });\n            }\n        }\n    };\n    const _updateIsValidating = (value1)=>_proxyFormState.isValidating && _subjects.state.next({\n            isValidating: value1\n        });\n    const _updateFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true)=>{\n        if (args && method) {\n            _state.action = true;\n            if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {\n                const fieldValues = method(get(_fields, name), args.argA, args.argB);\n                shouldSetValues && set(_fields, name, fieldValues);\n            }\n            if (shouldUpdateFieldsAndState && Array.isArray(get(_formState.errors, name))) {\n                const errors = method(get(_formState.errors, name), args.argA, args.argB);\n                shouldSetValues && set(_formState.errors, name, errors);\n                unsetEmptyArray(_formState.errors, name);\n            }\n            if (_proxyFormState.touchedFields && shouldUpdateFieldsAndState && Array.isArray(get(_formState.touchedFields, name))) {\n                const touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);\n                shouldSetValues && set(_formState.touchedFields, name, touchedFields);\n            }\n            if (_proxyFormState.dirtyFields) {\n                _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);\n            }\n            _subjects.state.next({\n                name,\n                isDirty: _getDirty(name, values),\n                dirtyFields: _formState.dirtyFields,\n                errors: _formState.errors,\n                isValid: _formState.isValid\n            });\n        } else {\n            set(_formValues, name, values);\n        }\n    };\n    const updateErrors = (name, error)=>{\n        set(_formState.errors, name, error);\n        _subjects.state.next({\n            errors: _formState.errors\n        });\n    };\n    const _setErrors = (errors)=>{\n        _formState.errors = errors;\n        _subjects.state.next({\n            errors: _formState.errors,\n            isValid: false\n        });\n    };\n    const updateValidAndValue = (name, shouldSkipSetValueAs, value1, ref)=>{\n        const field = get(_fields, name);\n        if (field) {\n            const defaultValue = get(_formValues, name, isUndefined(value1) ? get(_defaultValues, name) : value1);\n            isUndefined(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name, defaultValue);\n            _state.mount && _updateValid();\n        }\n    };\n    const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender)=>{\n        let shouldUpdateField = false;\n        let isPreviousDirty = false;\n        const output = {\n            name\n        };\n        const disabledField = !!(get(_fields, name) && get(_fields, name)._f.disabled);\n        if (!isBlurEvent || shouldDirty) {\n            if (_proxyFormState.isDirty) {\n                isPreviousDirty = _formState.isDirty;\n                _formState.isDirty = output.isDirty = _getDirty();\n                shouldUpdateField = isPreviousDirty !== output.isDirty;\n            }\n            const isCurrentFieldPristine = disabledField || deepEqual(get(_defaultValues, name), fieldValue);\n            isPreviousDirty = !!(!disabledField && get(_formState.dirtyFields, name));\n            isCurrentFieldPristine || disabledField ? unset(_formState.dirtyFields, name) : set(_formState.dirtyFields, name, true);\n            output.dirtyFields = _formState.dirtyFields;\n            shouldUpdateField = shouldUpdateField || _proxyFormState.dirtyFields && isPreviousDirty !== !isCurrentFieldPristine;\n        }\n        if (isBlurEvent) {\n            const isPreviousFieldTouched = get(_formState.touchedFields, name);\n            if (!isPreviousFieldTouched) {\n                set(_formState.touchedFields, name, isBlurEvent);\n                output.touchedFields = _formState.touchedFields;\n                shouldUpdateField = shouldUpdateField || _proxyFormState.touchedFields && isPreviousFieldTouched !== isBlurEvent;\n            }\n        }\n        shouldUpdateField && shouldRender && _subjects.state.next(output);\n        return shouldUpdateField ? output : {};\n    };\n    const shouldRenderByError = (name, isValid, error, fieldState)=>{\n        const previousFieldError = get(_formState.errors, name);\n        const shouldUpdateValid = _proxyFormState.isValid && isBoolean(isValid) && _formState.isValid !== isValid;\n        if (props.delayError && error) {\n            delayErrorCallback = debounce(()=>updateErrors(name, error));\n            delayErrorCallback(props.delayError);\n        } else {\n            clearTimeout(timer);\n            delayErrorCallback = null;\n            error ? set(_formState.errors, name, error) : unset(_formState.errors, name);\n        }\n        if ((error ? !deepEqual(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {\n            const updatedFormState = {\n                ...fieldState,\n                ...shouldUpdateValid && isBoolean(isValid) ? {\n                    isValid\n                } : {},\n                errors: _formState.errors,\n                name\n            };\n            _formState = {\n                ..._formState,\n                ...updatedFormState\n            };\n            _subjects.state.next(updatedFormState);\n        }\n        _updateIsValidating(false);\n    };\n    const _executeSchema = async (name)=>_options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));\n    const executeSchemaAndUpdateState = async (names)=>{\n        const { errors } = await _executeSchema(names);\n        if (names) {\n            for (const name of names){\n                const error = get(errors, name);\n                error ? set(_formState.errors, name, error) : unset(_formState.errors, name);\n            }\n        } else {\n            _formState.errors = errors;\n        }\n        return errors;\n    };\n    const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {\n        valid: true\n    })=>{\n        for(const name in fields){\n            const field = fields[name];\n            if (field) {\n                const { _f, ...fieldValue } = field;\n                if (_f) {\n                    const isFieldArrayRoot = _names.array.has(_f.name);\n                    const fieldError = await validateField(field, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);\n                    if (fieldError[_f.name]) {\n                        context.valid = false;\n                        if (shouldOnlyCheckValid) {\n                            break;\n                        }\n                    }\n                    !shouldOnlyCheckValid && (get(fieldError, _f.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name) : set(_formState.errors, _f.name, fieldError[_f.name]) : unset(_formState.errors, _f.name));\n                }\n                fieldValue && await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context);\n            }\n        }\n        return context.valid;\n    };\n    const _removeUnmounted = ()=>{\n        for (const name of _names.unMount){\n            const field = get(_fields, name);\n            field && (field._f.refs ? field._f.refs.every((ref)=>!live(ref)) : !live(field._f.ref)) && unregister(name);\n        }\n        _names.unMount = new Set();\n    };\n    const _getDirty = (name, data)=>(name && data && set(_formValues, name, data), !deepEqual(getValues(), _defaultValues));\n    const _getWatch = (names, defaultValue, isGlobal)=>generateWatchOutput(names, _names, {\n            ..._state.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString(names) ? {\n                [names]: defaultValue\n            } : defaultValue\n        }, isGlobal, defaultValue);\n    const _getFieldArray = (name)=>compact(get(_state.mount ? _formValues : _defaultValues, name, props.shouldUnregister ? get(_defaultValues, name, []) : []));\n    const setFieldValue = (name, value1, options = {})=>{\n        const field = get(_fields, name);\n        let fieldValue = value1;\n        if (field) {\n            const fieldReference = field._f;\n            if (fieldReference) {\n                !fieldReference.disabled && set(_formValues, name, getFieldValueAs(value1, fieldReference));\n                fieldValue = isHTMLElement(fieldReference.ref) && isNullOrUndefined(value1) ? \"\" : value1;\n                if (isMultipleSelect(fieldReference.ref)) {\n                    [\n                        ...fieldReference.ref.options\n                    ].forEach((optionRef)=>optionRef.selected = fieldValue.includes(optionRef.value));\n                } else if (fieldReference.refs) {\n                    if (isCheckBoxInput(fieldReference.ref)) {\n                        fieldReference.refs.length > 1 ? fieldReference.refs.forEach((checkboxRef)=>(!checkboxRef.defaultChecked || !checkboxRef.disabled) && (checkboxRef.checked = Array.isArray(fieldValue) ? !!fieldValue.find((data)=>data === checkboxRef.value) : fieldValue === checkboxRef.value)) : fieldReference.refs[0] && (fieldReference.refs[0].checked = !!fieldValue);\n                    } else {\n                        fieldReference.refs.forEach((radioRef)=>radioRef.checked = radioRef.value === fieldValue);\n                    }\n                } else if (isFileInput(fieldReference.ref)) {\n                    fieldReference.ref.value = \"\";\n                } else {\n                    fieldReference.ref.value = fieldValue;\n                    if (!fieldReference.ref.type) {\n                        _subjects.values.next({\n                            name,\n                            values: {\n                                ..._formValues\n                            }\n                        });\n                    }\n                }\n            }\n        }\n        (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);\n        options.shouldValidate && trigger(name);\n    };\n    const setValues = (name, value1, options)=>{\n        for(const fieldKey in value1){\n            const fieldValue = value1[fieldKey];\n            const fieldName = `${name}.${fieldKey}`;\n            const field = get(_fields, fieldName);\n            (_names.array.has(name) || !isPrimitive(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);\n        }\n    };\n    const setValue = (name, value1, options = {})=>{\n        const field = get(_fields, name);\n        const isFieldArray = _names.array.has(name);\n        const cloneValue = cloneObject(value1);\n        set(_formValues, name, cloneValue);\n        if (isFieldArray) {\n            _subjects.array.next({\n                name,\n                values: {\n                    ..._formValues\n                }\n            });\n            if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields) && options.shouldDirty) {\n                _subjects.state.next({\n                    name,\n                    dirtyFields: getDirtyFields(_defaultValues, _formValues),\n                    isDirty: _getDirty(name, cloneValue)\n                });\n            }\n        } else {\n            field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name, cloneValue, options) : setFieldValue(name, cloneValue, options);\n        }\n        isWatched(name, _names) && _subjects.state.next({\n            ..._formState\n        });\n        _subjects.values.next({\n            name,\n            values: {\n                ..._formValues\n            }\n        });\n        !_state.mount && flushRootRender();\n    };\n    const onChange = async (event)=>{\n        const target = event.target;\n        let name = target.name;\n        let isFieldValueUpdated = true;\n        const field = get(_fields, name);\n        const getCurrentFieldValue = ()=>target.type ? getFieldValue(field._f) : getEventValue(event);\n        const _updateIsFieldValueUpdated = (fieldValue)=>{\n            isFieldValueUpdated = Number.isNaN(fieldValue) || fieldValue === get(_formValues, name, fieldValue);\n        };\n        if (field) {\n            let error;\n            let isValid;\n            const fieldValue = getCurrentFieldValue();\n            const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;\n            const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);\n            const watched = isWatched(name, _names, isBlurEvent);\n            set(_formValues, name, fieldValue);\n            if (isBlurEvent) {\n                field._f.onBlur && field._f.onBlur(event);\n                delayErrorCallback && delayErrorCallback(0);\n            } else if (field._f.onChange) {\n                field._f.onChange(event);\n            }\n            const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent, false);\n            const shouldRender = !isEmptyObject(fieldState) || watched;\n            !isBlurEvent && _subjects.values.next({\n                name,\n                type: event.type,\n                values: {\n                    ..._formValues\n                }\n            });\n            if (shouldSkipValidation) {\n                _proxyFormState.isValid && _updateValid();\n                return shouldRender && _subjects.state.next({\n                    name,\n                    ...watched ? {} : fieldState\n                });\n            }\n            !isBlurEvent && watched && _subjects.state.next({\n                ..._formState\n            });\n            _updateIsValidating(true);\n            if (_options.resolver) {\n                const { errors } = await _executeSchema([\n                    name\n                ]);\n                _updateIsFieldValueUpdated(fieldValue);\n                if (isFieldValueUpdated) {\n                    const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);\n                    const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);\n                    error = errorLookupResult.error;\n                    name = errorLookupResult.name;\n                    isValid = isEmptyObject(errors);\n                }\n            } else {\n                error = (await validateField(field, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];\n                _updateIsFieldValueUpdated(fieldValue);\n                if (isFieldValueUpdated) {\n                    if (error) {\n                        isValid = false;\n                    } else if (_proxyFormState.isValid) {\n                        isValid = await executeBuiltInValidation(_fields, true);\n                    }\n                }\n            }\n            if (isFieldValueUpdated) {\n                field._f.deps && trigger(field._f.deps);\n                shouldRenderByError(name, isValid, error, fieldState);\n            }\n        }\n    };\n    const _focusInput = (ref, key)=>{\n        if (get(_formState.errors, key) && ref.focus) {\n            ref.focus();\n            return 1;\n        }\n        return;\n    };\n    const trigger = async (name, options = {})=>{\n        let isValid;\n        let validationResult;\n        const fieldNames = convertToArrayPayload(name);\n        _updateIsValidating(true);\n        if (_options.resolver) {\n            const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);\n            isValid = isEmptyObject(errors);\n            validationResult = name ? !fieldNames.some((name)=>get(errors, name)) : isValid;\n        } else if (name) {\n            validationResult = (await Promise.all(fieldNames.map(async (fieldName)=>{\n                const field = get(_fields, fieldName);\n                return await executeBuiltInValidation(field && field._f ? {\n                    [fieldName]: field\n                } : field);\n            }))).every(Boolean);\n            !(!validationResult && !_formState.isValid) && _updateValid();\n        } else {\n            validationResult = isValid = await executeBuiltInValidation(_fields);\n        }\n        _subjects.state.next({\n            ...!isString(name) || _proxyFormState.isValid && isValid !== _formState.isValid ? {} : {\n                name\n            },\n            ..._options.resolver || !name ? {\n                isValid\n            } : {},\n            errors: _formState.errors,\n            isValidating: false\n        });\n        options.shouldFocus && !validationResult && iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);\n        return validationResult;\n    };\n    const getValues = (fieldNames)=>{\n        const values = {\n            ..._defaultValues,\n            ..._state.mount ? _formValues : {}\n        };\n        return isUndefined(fieldNames) ? values : isString(fieldNames) ? get(values, fieldNames) : fieldNames.map((name)=>get(values, name));\n    };\n    const getFieldState = (name, formState)=>({\n            invalid: !!get((formState || _formState).errors, name),\n            isDirty: !!get((formState || _formState).dirtyFields, name),\n            isTouched: !!get((formState || _formState).touchedFields, name),\n            error: get((formState || _formState).errors, name)\n        });\n    const clearErrors = (name)=>{\n        name && convertToArrayPayload(name).forEach((inputName)=>unset(_formState.errors, inputName));\n        _subjects.state.next({\n            errors: name ? _formState.errors : {}\n        });\n    };\n    const setError = (name, error, options)=>{\n        const ref = (get(_fields, name, {\n            _f: {}\n        })._f || {}).ref;\n        set(_formState.errors, name, {\n            ...error,\n            ref\n        });\n        _subjects.state.next({\n            name,\n            errors: _formState.errors,\n            isValid: false\n        });\n        options && options.shouldFocus && ref && ref.focus && ref.focus();\n    };\n    const watch = (name, defaultValue)=>isFunction(name) ? _subjects.values.subscribe({\n            next: (payload)=>name(_getWatch(undefined, defaultValue), payload)\n        }) : _getWatch(name, defaultValue, true);\n    const unregister = (name, options = {})=>{\n        for (const fieldName of name ? convertToArrayPayload(name) : _names.mount){\n            _names.mount.delete(fieldName);\n            _names.array.delete(fieldName);\n            if (!options.keepValue) {\n                unset(_fields, fieldName);\n                unset(_formValues, fieldName);\n            }\n            !options.keepError && unset(_formState.errors, fieldName);\n            !options.keepDirty && unset(_formState.dirtyFields, fieldName);\n            !options.keepTouched && unset(_formState.touchedFields, fieldName);\n            !_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);\n        }\n        _subjects.values.next({\n            values: {\n                ..._formValues\n            }\n        });\n        _subjects.state.next({\n            ..._formState,\n            ...!options.keepDirty ? {} : {\n                isDirty: _getDirty()\n            }\n        });\n        !options.keepIsValid && _updateValid();\n    };\n    const _updateDisabledField = ({ disabled, name, field, fields, value: value1 })=>{\n        if (isBoolean(disabled)) {\n            const inputValue = disabled ? undefined : isUndefined(value1) ? getFieldValue(field ? field._f : get(fields, name)._f) : value1;\n            set(_formValues, name, inputValue);\n            updateTouchAndDirty(name, inputValue, false, false, true);\n        }\n    };\n    const register = (name, options = {})=>{\n        let field = get(_fields, name);\n        const disabledIsDefined = isBoolean(options.disabled);\n        set(_fields, name, {\n            ...field || {},\n            _f: {\n                ...field && field._f ? field._f : {\n                    ref: {\n                        name\n                    }\n                },\n                name,\n                mount: true,\n                ...options\n            }\n        });\n        _names.mount.add(name);\n        if (field) {\n            _updateDisabledField({\n                field,\n                disabled: options.disabled,\n                name,\n                value: options.value\n            });\n        } else {\n            updateValidAndValue(name, true, options.value);\n        }\n        return {\n            ...disabledIsDefined ? {\n                disabled: options.disabled\n            } : {},\n            ..._options.progressive ? {\n                required: !!options.required,\n                min: getRuleValue(options.min),\n                max: getRuleValue(options.max),\n                minLength: getRuleValue(options.minLength),\n                maxLength: getRuleValue(options.maxLength),\n                pattern: getRuleValue(options.pattern)\n            } : {},\n            name,\n            onChange,\n            onBlur: onChange,\n            ref: (ref)=>{\n                if (ref) {\n                    register(name, options);\n                    field = get(_fields, name);\n                    const fieldRef = isUndefined(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll(\"input,select,textarea\")[0] || ref : ref : ref;\n                    const radioOrCheckbox = isRadioOrCheckbox(fieldRef);\n                    const refs = field._f.refs || [];\n                    if (radioOrCheckbox ? refs.find((option)=>option === fieldRef) : fieldRef === field._f.ref) {\n                        return;\n                    }\n                    set(_fields, name, {\n                        _f: {\n                            ...field._f,\n                            ...radioOrCheckbox ? {\n                                refs: [\n                                    ...refs.filter(live),\n                                    fieldRef,\n                                    ...Array.isArray(get(_defaultValues, name)) ? [\n                                        {}\n                                    ] : []\n                                ],\n                                ref: {\n                                    type: fieldRef.type,\n                                    name\n                                }\n                            } : {\n                                ref: fieldRef\n                            }\n                        }\n                    });\n                    updateValidAndValue(name, false, undefined, fieldRef);\n                } else {\n                    field = get(_fields, name, {});\n                    if (field._f) {\n                        field._f.mount = false;\n                    }\n                    (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _state.action) && _names.unMount.add(name);\n                }\n            }\n        };\n    };\n    const _focusError = ()=>_options.shouldFocusError && iterateFieldsByAction(_fields, _focusInput, _names.mount);\n    const _disableForm = (disabled)=>{\n        if (isBoolean(disabled)) {\n            _subjects.state.next({\n                disabled\n            });\n            iterateFieldsByAction(_fields, (ref, name)=>{\n                let requiredDisabledState = disabled;\n                const currentField = get(_fields, name);\n                if (currentField && isBoolean(currentField._f.disabled)) {\n                    requiredDisabledState || (requiredDisabledState = currentField._f.disabled);\n                }\n                ref.disabled = requiredDisabledState;\n            }, 0, false);\n        }\n    };\n    const handleSubmit = (onValid, onInvalid)=>async (e)=>{\n            let onValidError = undefined;\n            if (e) {\n                e.preventDefault && e.preventDefault();\n                e.persist && e.persist();\n            }\n            let fieldValues = cloneObject(_formValues);\n            _subjects.state.next({\n                isSubmitting: true\n            });\n            if (_options.resolver) {\n                const { errors, values } = await _executeSchema();\n                _formState.errors = errors;\n                fieldValues = values;\n            } else {\n                await executeBuiltInValidation(_fields);\n            }\n            unset(_formState.errors, \"root\");\n            if (isEmptyObject(_formState.errors)) {\n                _subjects.state.next({\n                    errors: {}\n                });\n                try {\n                    await onValid(fieldValues, e);\n                } catch (error) {\n                    onValidError = error;\n                }\n            } else {\n                if (onInvalid) {\n                    await onInvalid({\n                        ..._formState.errors\n                    }, e);\n                }\n                _focusError();\n                setTimeout(_focusError);\n            }\n            _subjects.state.next({\n                isSubmitted: true,\n                isSubmitting: false,\n                isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,\n                submitCount: _formState.submitCount + 1,\n                errors: _formState.errors\n            });\n            if (onValidError) {\n                throw onValidError;\n            }\n        };\n    const resetField = (name, options = {})=>{\n        if (get(_fields, name)) {\n            if (isUndefined(options.defaultValue)) {\n                setValue(name, cloneObject(get(_defaultValues, name)));\n            } else {\n                setValue(name, options.defaultValue);\n                set(_defaultValues, name, cloneObject(options.defaultValue));\n            }\n            if (!options.keepTouched) {\n                unset(_formState.touchedFields, name);\n            }\n            if (!options.keepDirty) {\n                unset(_formState.dirtyFields, name);\n                _formState.isDirty = options.defaultValue ? _getDirty(name, cloneObject(get(_defaultValues, name))) : _getDirty();\n            }\n            if (!options.keepError) {\n                unset(_formState.errors, name);\n                _proxyFormState.isValid && _updateValid();\n            }\n            _subjects.state.next({\n                ..._formState\n            });\n        }\n    };\n    const _reset = (formValues, keepStateOptions = {})=>{\n        const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;\n        const cloneUpdatedValues = cloneObject(updatedValues);\n        const values = formValues && !isEmptyObject(formValues) ? cloneUpdatedValues : _defaultValues;\n        if (!keepStateOptions.keepDefaultValues) {\n            _defaultValues = updatedValues;\n        }\n        if (!keepStateOptions.keepValues) {\n            if (keepStateOptions.keepDirtyValues) {\n                for (const fieldName of _names.mount){\n                    get(_formState.dirtyFields, fieldName) ? set(values, fieldName, get(_formValues, fieldName)) : setValue(fieldName, get(values, fieldName));\n                }\n            } else {\n                if (isWeb && isUndefined(formValues)) {\n                    for (const name of _names.mount){\n                        const field = get(_fields, name);\n                        if (field && field._f) {\n                            const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;\n                            if (isHTMLElement(fieldReference)) {\n                                const form = fieldReference.closest(\"form\");\n                                if (form) {\n                                    form.reset();\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n                _fields = {};\n            }\n            _formValues = props.shouldUnregister ? keepStateOptions.keepDefaultValues ? cloneObject(_defaultValues) : {} : cloneObject(values);\n            _subjects.array.next({\n                values: {\n                    ...values\n                }\n            });\n            _subjects.values.next({\n                values: {\n                    ...values\n                }\n            });\n        }\n        _names = {\n            mount: new Set(),\n            unMount: new Set(),\n            array: new Set(),\n            watch: new Set(),\n            watchAll: false,\n            focus: \"\"\n        };\n        !_state.mount && flushRootRender();\n        _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid || !!keepStateOptions.keepDirtyValues;\n        _state.watch = !!props.shouldUnregister;\n        _subjects.state.next({\n            submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,\n            isDirty: keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual(formValues, _defaultValues)),\n            isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,\n            dirtyFields: keepStateOptions.keepDirtyValues ? keepStateOptions.keepDefaultValues && _formValues ? getDirtyFields(_defaultValues, _formValues) : _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : {},\n            touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},\n            errors: keepStateOptions.keepErrors ? _formState.errors : {},\n            isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful ? _formState.isSubmitSuccessful : false,\n            isSubmitting: false\n        });\n    };\n    const reset = (formValues, keepStateOptions)=>_reset(isFunction(formValues) ? formValues(_formValues) : formValues, keepStateOptions);\n    const setFocus = (name, options = {})=>{\n        const field = get(_fields, name);\n        const fieldReference = field && field._f;\n        if (fieldReference) {\n            const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;\n            if (fieldRef.focus) {\n                fieldRef.focus();\n                options.shouldSelect && fieldRef.select();\n            }\n        }\n    };\n    const _updateFormState = (updatedFormState)=>{\n        _formState = {\n            ..._formState,\n            ...updatedFormState\n        };\n    };\n    const _resetDefaultValues = ()=>isFunction(_options.defaultValues) && _options.defaultValues().then((values)=>{\n            reset(values, _options.resetOptions);\n            _subjects.state.next({\n                isLoading: false\n            });\n        });\n    return {\n        control: {\n            register,\n            unregister,\n            getFieldState,\n            handleSubmit,\n            setError,\n            _executeSchema,\n            _getWatch,\n            _getDirty,\n            _updateValid,\n            _removeUnmounted,\n            _updateFieldArray,\n            _updateDisabledField,\n            _getFieldArray,\n            _reset,\n            _resetDefaultValues,\n            _updateFormState,\n            _disableForm,\n            _subjects,\n            _proxyFormState,\n            _setErrors,\n            get _fields () {\n                return _fields;\n            },\n            get _formValues () {\n                return _formValues;\n            },\n            get _state () {\n                return _state;\n            },\n            set _state (value){\n                _state = value;\n            },\n            get _defaultValues () {\n                return _defaultValues;\n            },\n            get _names () {\n                return _names;\n            },\n            set _names (value){\n                _names = value;\n            },\n            get _formState () {\n                return _formState;\n            },\n            set _formState (value){\n                _formState = value;\n            },\n            get _options () {\n                return _options;\n            },\n            set _options (value){\n                _options = {\n                    ..._options,\n                    ...value\n                };\n            }\n        },\n        trigger,\n        register,\n        handleSubmit,\n        watch,\n        setValue,\n        getValues,\n        reset,\n        resetField,\n        clearErrors,\n        unregister,\n        setError,\n        setFocus,\n        getFieldState\n    };\n}\n/**\n * Custom hook to manage the entire form.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useform) • [Demo](https://codesandbox.io/s/react-hook-form-get-started-ts-5ksmm) • [Video](https://www.youtube.com/watch?v=RkXv4AXXC_4)\n *\n * @param props - form configuration and validation parameters.\n *\n * @returns methods - individual functions to manage the form state. {@link UseFormReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, handleSubmit, watch, formState: { errors } } = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   console.log(watch(\"example\"));\n *\n *   return (\n *     <form onSubmit={handleSubmit(onSubmit)}>\n *       <input defaultValue=\"test\" {...register(\"example\")} />\n *       <input {...register(\"exampleRequired\", { required: true })} />\n *       {errors.exampleRequired && <span>This field is required</span>}\n *       <button>Submit</button>\n *     </form>\n *   );\n * }\n * ```\n */ function useForm(props = {}) {\n    const _formControl = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const _values = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        isDirty: false,\n        isValidating: false,\n        isLoading: isFunction(props.defaultValues),\n        isSubmitted: false,\n        isSubmitting: false,\n        isSubmitSuccessful: false,\n        isValid: false,\n        submitCount: 0,\n        dirtyFields: {},\n        touchedFields: {},\n        errors: props.errors || {},\n        disabled: props.disabled || false,\n        defaultValues: isFunction(props.defaultValues) ? undefined : props.defaultValues\n    });\n    if (!_formControl.current) {\n        _formControl.current = {\n            ...createFormControl(props, ()=>updateFormState((formState)=>({\n                        ...formState\n                    }))),\n            formState\n        };\n    }\n    const control = _formControl.current.control;\n    control._options = props;\n    useSubscribe({\n        subject: control._subjects.state,\n        next: (value1)=>{\n            if (shouldRenderFormState(value1, control._proxyFormState, control._updateFormState, true)) {\n                updateFormState({\n                    ...control._formState\n                });\n            }\n        }\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>control._disableForm(props.disabled), [\n        control,\n        props.disabled\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (control._proxyFormState.isDirty) {\n            const isDirty = control._getDirty();\n            if (isDirty !== formState.isDirty) {\n                control._subjects.state.next({\n                    isDirty\n                });\n            }\n        }\n    }, [\n        control,\n        formState.isDirty\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (props.values && !deepEqual(props.values, _values.current)) {\n            control._reset(props.values, control._options.resetOptions);\n            _values.current = props.values;\n            updateFormState((state)=>({\n                    ...state\n                }));\n        } else {\n            control._resetDefaultValues();\n        }\n    }, [\n        props.values,\n        control\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (props.errors) {\n            control._setErrors(props.errors);\n        }\n    }, [\n        props.errors,\n        control\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!control._state.mount) {\n            control._updateValid();\n            control._state.mount = true;\n        }\n        if (control._state.watch) {\n            control._state.watch = false;\n            control._subjects.state.next({\n                ...control._formState\n            });\n        }\n        control._removeUnmounted();\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        props.shouldUnregister && control._subjects.values.next({\n            values: control._getWatch()\n        });\n    }, [\n        props.shouldUnregister,\n        control\n    ]);\n    _formControl.current.formState = getProxyFormState(formState, control);\n    return _formControl.current;\n}\n //# sourceMappingURL=index.esm.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWhvb2stZm9ybUA3LjUwLjFfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1ob29rLWZvcm0vZGlzdC9pbmRleC5lc20ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEI7QUFFMUIsSUFBSUMsa0JBQWtCLENBQUNDLFVBQVlBLFFBQVFDLElBQUksS0FBSztBQUVwRCxJQUFJQyxlQUFlLENBQUNDLFNBQVVBLGtCQUFpQkM7QUFFL0MsSUFBSUMsb0JBQW9CLENBQUNGLFNBQVVBLFVBQVM7QUFFNUMsTUFBTUcsZUFBZSxDQUFDSCxTQUFVLE9BQU9BLFdBQVU7QUFDakQsSUFBSUksV0FBVyxDQUFDSixTQUFVLENBQUNFLGtCQUFrQkYsV0FDekMsQ0FBQ0ssTUFBTUMsT0FBTyxDQUFDTixXQUNmRyxhQUFhSCxXQUNiLENBQUNELGFBQWFDO0FBRWxCLElBQUlPLGdCQUFnQixDQUFDQyxRQUFVSixTQUFTSSxVQUFVQSxNQUFNQyxNQUFNLEdBQ3hEYixnQkFBZ0JZLE1BQU1DLE1BQU0sSUFDeEJELE1BQU1DLE1BQU0sQ0FBQ0MsT0FBTyxHQUNwQkYsTUFBTUMsTUFBTSxDQUFDVCxLQUFLLEdBQ3RCUTtBQUVOLElBQUlHLG9CQUFvQixDQUFDQyxPQUFTQSxLQUFLQyxTQUFTLENBQUMsR0FBR0QsS0FBS0UsTUFBTSxDQUFDLG1CQUFtQkY7QUFFbkYsSUFBSUcscUJBQXFCLENBQUNDLE9BQU9KLE9BQVNJLE1BQU1DLEdBQUcsQ0FBQ04sa0JBQWtCQztBQUV0RSxJQUFJTSxnQkFBZ0IsQ0FBQ0M7SUFDakIsTUFBTUMsZ0JBQWdCRCxXQUFXRSxXQUFXLElBQUlGLFdBQVdFLFdBQVcsQ0FBQ0MsU0FBUztJQUNoRixPQUFRbEIsU0FBU2dCLGtCQUFrQkEsY0FBY0csY0FBYyxDQUFDO0FBQ3BFO0FBRUEsSUFBSUMsUUFBUSxNQUNzQixJQUM5QixDQUFvQjtBQUV4QixTQUFTSSxZQUFZQyxJ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RUFBRTtZQUN2QjdGLFFBQVFtRCxZQUFZO1lBQ3BCbkQsUUFBUThGLE1BQU0sQ0FBQ0QsS0FBSyxHQUFHO1FBQzNCO1FBQ0EsSUFBSTdGLFFBQVE4RixNQUFNLENBQUNyQyxLQUFLLEVBQUU7WUFDdEJ6RCxRQUFROEYsTUFBTSxDQUFDckMsS0FBSyxHQUFHO1lBQ3ZCekQsUUFBUWlELFNBQVMsQ0FBQ0MsS0FBSyxDQUFDbEIsSUFBSSxDQUFDO2dCQUFFLEdBQUdoQyxRQUFRcUMsVUFBVTtZQUFDO1FBQ3pEO1FBQ0FyQyxRQUFRbUUsZ0JBQWdCO0lBQzVCO0lBQ0F0Siw0Q0FBZSxDQUFDO1FBQ1o2RSxNQUFNdUYsZ0JBQWdCLElBQ2xCakYsUUFBUWlELFNBQVMsQ0FBQ2MsTUFBTSxDQUFDL0IsSUFBSSxDQUFDO1lBQzFCK0IsUUFBUS9ELFFBQVFrRSxTQUFTO1FBQzdCO0lBQ1IsR0FBRztRQUFDeEUsTUFBTXVGLGdCQUFnQjtRQUFFakY7S0FBUTtJQUNwQzRjLGFBQWFsYixPQUFPLENBQUMzQixTQUFTLEdBQUdELGtCQUFrQkMsV0FBV0M7SUFDOUQsT0FBTzRjLGFBQWFsYixPQUFPO0FBQy9CO0FBRWlKLENBQ2pKLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtaG9vay1mb3JtQDcuNTAuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL3JlYWN0LWhvb2stZm9ybS9kaXN0L2luZGV4LmVzbS5tanM/YjNhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG52YXIgaXNDaGVja0JveElucHV0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gJ2NoZWNrYm94JztcblxudmFyIGlzRGF0ZU9iamVjdCA9ICh2YWx1ZSkgPT4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlO1xuXG52YXIgaXNOdWxsT3JVbmRlZmluZWQgPSAodmFsdWUpID0+IHZhbHVlID09IG51bGw7XG5cbmNvbnN0IGlzT2JqZWN0VHlwZSA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JztcbnZhciBpc09iamVjdCA9ICh2YWx1ZSkgPT4gIWlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSAmJlxuICAgICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJlxuICAgIGlzT2JqZWN0VHlwZSh2YWx1ZSkgJiZcbiAgICAhaXNEYXRlT2JqZWN0KHZhbHVlKTtcblxudmFyIGdldEV2ZW50VmFsdWUgPSAoZXZlbnQpID0+IGlzT2JqZWN0KGV2ZW50KSAmJiBldmVudC50YXJnZXRcbiAgICA/IGlzQ2hlY2tCb3hJbnB1dChldmVudC50YXJnZXQpXG4gICAgICAgID8gZXZlbnQudGFyZ2V0LmNoZWNrZWRcbiAgICAgICAgOiBldmVudC50YXJnZXQudmFsdWVcbiAgICA6IGV2ZW50O1xuXG52YXIgZ2V0Tm9kZVBhcmVudE5hbWUgPSAobmFtZSkgPT4gbmFtZS5zdWJzdHJpbmcoMCwgbmFtZS5zZWFyY2goL1xcLlxcZCsoXFwufCQpLykpIHx8IG5hbWU7XG5cbnZhciBpc05hbWVJbkZpZWxkQXJyYXkgPSAobmFtZXMsIG5hbWUpID0+IG5hbWVzLmhhcyhnZXROb2RlUGFyZW50TmFtZShuYW1lKSk7XG5cbnZhciBpc1BsYWluT2JqZWN0ID0gKHRlbXBPYmplY3QpID0+IHtcbiAgICBjb25zdCBwcm90b3R5cGVDb3B5ID0gdGVtcE9iamVjdC5jb25zdHJ1Y3RvciAmJiB0ZW1wT2JqZWN0LmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICByZXR1cm4gKGlzT2JqZWN0KHByb3RvdHlwZUNvcHkpICYmIHByb3RvdHlwZUNvcHkuaGFzT3duUHJvcGVydHkoJ2lzUHJvdG90eXBlT2YnKSk7XG59O1xuXG52YXIgaXNXZWIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cuSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuZnVuY3Rpb24gY2xvbmVPYmplY3QoZGF0YSkge1xuICAgIGxldCBjb3B5O1xuICAgIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGRhdGEpO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBjb3B5ID0gbmV3IERhdGUoZGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgY29weSA9IG5ldyBTZXQoZGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCEoaXNXZWIgJiYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iIHx8IGRhdGEgaW5zdGFuY2VvZiBGaWxlTGlzdCkpICYmXG4gICAgICAgIChpc0FycmF5IHx8IGlzT2JqZWN0KGRhdGEpKSkge1xuICAgICAgICBjb3B5ID0gaXNBcnJheSA/IFtdIDoge307XG4gICAgICAgIGlmICghaXNBcnJheSAmJiAhaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgICAgICAgY29weSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb3B5W2tleV0gPSBjbG9uZU9iamVjdChkYXRhW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xufVxuXG52YXIgY29tcGFjdCA9ICh2YWx1ZSkgPT4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5maWx0ZXIoQm9vbGVhbikgOiBbXTtcblxudmFyIGlzVW5kZWZpbmVkID0gKHZhbCkgPT4gdmFsID09PSB1bmRlZmluZWQ7XG5cbnZhciBnZXQgPSAob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgICBpZiAoIXBhdGggfHwgIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gY29tcGFjdChwYXRoLnNwbGl0KC9bLFtcXF0uXSs/LykpLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IGlzTnVsbE9yVW5kZWZpbmVkKHJlc3VsdCkgPyByZXN1bHQgOiByZXN1bHRba2V5XSwgb2JqZWN0KTtcbiAgICByZXR1cm4gaXNVbmRlZmluZWQocmVzdWx0KSB8fCByZXN1bHQgPT09IG9iamVjdFxuICAgICAgICA/IGlzVW5kZWZpbmVkKG9iamVjdFtwYXRoXSlcbiAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICA6IG9iamVjdFtwYXRoXVxuICAgICAgICA6IHJlc3VsdDtcbn07XG5cbnZhciBpc0Jvb2xlYW4gPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuXG5jb25zdCBFVkVOVFMgPSB7XG4gICAgQkxVUjogJ2JsdXInLFxuICAgIEZPQ1VTX09VVDogJ2ZvY3Vzb3V0JyxcbiAgICBDSEFOR0U6ICdjaGFuZ2UnLFxufTtcbmNvbnN0IFZBTElEQVRJT05fTU9ERSA9IHtcbiAgICBvbkJsdXI6ICdvbkJsdXInLFxuICAgIG9uQ2hhbmdlOiAnb25DaGFuZ2UnLFxuICAgIG9uU3VibWl0OiAnb25TdWJtaXQnLFxuICAgIG9uVG91Y2hlZDogJ29uVG91Y2hlZCcsXG4gICAgYWxsOiAnYWxsJyxcbn07XG5jb25zdCBJTlBVVF9WQUxJREFUSU9OX1JVTEVTID0ge1xuICAgIG1heDogJ21heCcsXG4gICAgbWluOiAnbWluJyxcbiAgICBtYXhMZW5ndGg6ICdtYXhMZW5ndGgnLFxuICAgIG1pbkxlbmd0aDogJ21pbkxlbmd0aCcsXG4gICAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICAgIHJlcXVpcmVkOiAncmVxdWlyZWQnLFxuICAgIHZhbGlkYXRlOiAndmFsaWRhdGUnLFxufTtcblxuY29uc3QgSG9va0Zvcm1Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbi8qKlxuICogVGhpcyBjdXN0b20gaG9vayBhbGxvd3MgeW91IHRvIGFjY2VzcyB0aGUgZm9ybSBjb250ZXh0LiB1c2VGb3JtQ29udGV4dCBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGluIGRlZXBseSBuZXN0ZWQgc3RydWN0dXJlcywgd2hlcmUgaXQgd291bGQgYmVjb21lIGluY29udmVuaWVudCB0byBwYXNzIHRoZSBjb250ZXh0IGFzIGEgcHJvcC4gVG8gYmUgdXNlZCB3aXRoIHtAbGluayBGb3JtUHJvdmlkZXJ9LlxuICpcbiAqIEByZW1hcmtzXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2Vmb3JtY29udGV4dCkg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvcmVhY3QtaG9vay1mb3JtLXY3LWZvcm0tY29udGV4dC15dHVkaSlcbiAqXG4gKiBAcmV0dXJucyByZXR1cm4gYWxsIHVzZUZvcm0gbWV0aG9kc1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgY29uc3QgbWV0aG9kcyA9IHVzZUZvcm0oKTtcbiAqICAgY29uc3Qgb25TdWJtaXQgPSBkYXRhID0+IGNvbnNvbGUubG9nKGRhdGEpO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Rm9ybVByb3ZpZGVyIHsuLi5tZXRob2RzfSA+XG4gKiAgICAgICA8Zm9ybSBvblN1Ym1pdD17bWV0aG9kcy5oYW5kbGVTdWJtaXQob25TdWJtaXQpfT5cbiAqICAgICAgICAgPE5lc3RlZElucHV0IC8+XG4gKiAgICAgICAgIDxpbnB1dCB0eXBlPVwic3VibWl0XCIgLz5cbiAqICAgICAgIDwvZm9ybT5cbiAqICAgICA8L0Zvcm1Qcm92aWRlcj5cbiAqICAgKTtcbiAqIH1cbiAqXG4gKiAgZnVuY3Rpb24gTmVzdGVkSW5wdXQoKSB7XG4gKiAgIGNvbnN0IHsgcmVnaXN0ZXIgfSA9IHVzZUZvcm1Db250ZXh0KCk7IC8vIHJldHJpZXZlIGFsbCBob29rIG1ldGhvZHNcbiAqICAgcmV0dXJuIDxpbnB1dCB7Li4ucmVnaXN0ZXIoXCJ0ZXN0XCIpfSAvPjtcbiAqIH1cbiAqIGBgYFxuICovXG5jb25zdCB1c2VGb3JtQ29udGV4dCA9ICgpID0+IFJlYWN0LnVzZUNvbnRleHQoSG9va0Zvcm1Db250ZXh0KTtcbi8qKlxuICogQSBwcm92aWRlciBjb21wb25lbnQgdGhhdCBwcm9wYWdhdGVzIHRoZSBgdXNlRm9ybWAgbWV0aG9kcyB0byBhbGwgY2hpbGRyZW4gY29tcG9uZW50cyB2aWEgW1JlYWN0IENvbnRleHRdKGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9jb250ZXh0Lmh0bWwpIEFQSS4gVG8gYmUgdXNlZCB3aXRoIHtAbGluayB1c2VGb3JtQ29udGV4dH0uXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWZvcm1jb250ZXh0KSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tdjctZm9ybS1jb250ZXh0LXl0dWRpKVxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIGFsbCB1c2VGb3JtIG1ldGhvZHNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtKCk7XG4gKiAgIGNvbnN0IG9uU3VibWl0ID0gZGF0YSA9PiBjb25zb2xlLmxvZyhkYXRhKTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPEZvcm1Qcm92aWRlciB7Li4ubWV0aG9kc30gPlxuICogICAgICAgPGZvcm0gb25TdWJtaXQ9e21ldGhvZHMuaGFuZGxlU3VibWl0KG9uU3VibWl0KX0+XG4gKiAgICAgICAgIDxOZXN0ZWRJbnB1dCAvPlxuICogICAgICAgICA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiIC8+XG4gKiAgICAgICA8L2Zvcm0+XG4gKiAgICAgPC9Gb3JtUHJvdmlkZXI+XG4gKiAgICk7XG4gKiB9XG4gKlxuICogIGZ1bmN0aW9uIE5lc3RlZElucHV0KCkge1xuICogICBjb25zdCB7IHJlZ2lzdGVyIH0gPSB1c2VGb3JtQ29udGV4dCgpOyAvLyByZXRyaWV2ZSBhbGwgaG9vayBtZXRob2RzXG4gKiAgIHJldHVybiA8aW5wdXQgey4uLnJlZ2lzdGVyKFwidGVzdFwiKX0gLz47XG4gKiB9XG4gKiBgYGBcbiAqL1xuY29uc3QgRm9ybVByb3ZpZGVyID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgLi4uZGF0YSB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEhvb2tGb3JtQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogZGF0YSB9LCBjaGlsZHJlbikpO1xufTtcblxudmFyIGdldFByb3h5Rm9ybVN0YXRlID0gKGZvcm1TdGF0ZSwgY29udHJvbCwgbG9jYWxQcm94eUZvcm1TdGF0ZSwgaXNSb290ID0gdHJ1ZSkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgZGVmYXVsdFZhbHVlczogY29udHJvbC5fZGVmYXVsdFZhbHVlcyxcbiAgICB9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGZvcm1TdGF0ZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBrZXksIHtcbiAgICAgICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9rZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2wuX3Byb3h5Rm9ybVN0YXRlW19rZXldICE9PSBWQUxJREFUSU9OX01PREUuYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuX3Byb3h5Rm9ybVN0YXRlW19rZXldID0gIWlzUm9vdCB8fCBWQUxJREFUSU9OX01PREUuYWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbFByb3h5Rm9ybVN0YXRlICYmIChsb2NhbFByb3h5Rm9ybVN0YXRlW19rZXldID0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1TdGF0ZVtfa2V5XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGlzRW1wdHlPYmplY3QgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSAmJiAhT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aDtcblxudmFyIHNob3VsZFJlbmRlckZvcm1TdGF0ZSA9IChmb3JtU3RhdGVEYXRhLCBfcHJveHlGb3JtU3RhdGUsIHVwZGF0ZUZvcm1TdGF0ZSwgaXNSb290KSA9PiB7XG4gICAgdXBkYXRlRm9ybVN0YXRlKGZvcm1TdGF0ZURhdGEpO1xuICAgIGNvbnN0IHsgbmFtZSwgLi4uZm9ybVN0YXRlIH0gPSBmb3JtU3RhdGVEYXRhO1xuICAgIHJldHVybiAoaXNFbXB0eU9iamVjdChmb3JtU3RhdGUpIHx8XG4gICAgICAgIE9iamVjdC5rZXlzKGZvcm1TdGF0ZSkubGVuZ3RoID49IE9iamVjdC5rZXlzKF9wcm94eUZvcm1TdGF0ZSkubGVuZ3RoIHx8XG4gICAgICAgIE9iamVjdC5rZXlzKGZvcm1TdGF0ZSkuZmluZCgoa2V5KSA9PiBfcHJveHlGb3JtU3RhdGVba2V5XSA9PT1cbiAgICAgICAgICAgICghaXNSb290IHx8IFZBTElEQVRJT05fTU9ERS5hbGwpKSk7XG59O1xuXG52YXIgY29udmVydFRvQXJyYXlQYXlsb2FkID0gKHZhbHVlKSA9PiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV0pO1xuXG52YXIgc2hvdWxkU3Vic2NyaWJlQnlOYW1lID0gKG5hbWUsIHNpZ25hbE5hbWUsIGV4YWN0KSA9PiAhbmFtZSB8fFxuICAgICFzaWduYWxOYW1lIHx8XG4gICAgbmFtZSA9PT0gc2lnbmFsTmFtZSB8fFxuICAgIGNvbnZlcnRUb0FycmF5UGF5bG9hZChuYW1lKS5zb21lKChjdXJyZW50TmFtZSkgPT4gY3VycmVudE5hbWUgJiZcbiAgICAgICAgKGV4YWN0XG4gICAgICAgICAgICA/IGN1cnJlbnROYW1lID09PSBzaWduYWxOYW1lXG4gICAgICAgICAgICA6IGN1cnJlbnROYW1lLnN0YXJ0c1dpdGgoc2lnbmFsTmFtZSkgfHxcbiAgICAgICAgICAgICAgICBzaWduYWxOYW1lLnN0YXJ0c1dpdGgoY3VycmVudE5hbWUpKSk7XG5cbmZ1bmN0aW9uIHVzZVN1YnNjcmliZShwcm9wcykge1xuICAgIGNvbnN0IF9wcm9wcyA9IFJlYWN0LnVzZVJlZihwcm9wcyk7XG4gICAgX3Byb3BzLmN1cnJlbnQgPSBwcm9wcztcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSAhcHJvcHMuZGlzYWJsZWQgJiZcbiAgICAgICAgICAgIF9wcm9wcy5jdXJyZW50LnN1YmplY3QgJiZcbiAgICAgICAgICAgIF9wcm9wcy5jdXJyZW50LnN1YmplY3Quc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICBuZXh0OiBfcHJvcHMuY3VycmVudC5uZXh0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gJiYgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH07XG4gICAgfSwgW3Byb3BzLmRpc2FibGVkXSk7XG59XG5cbi8qKlxuICogVGhpcyBjdXN0b20gaG9vayBhbGxvd3MgeW91IHRvIHN1YnNjcmliZSB0byBlYWNoIGZvcm0gc3RhdGUsIGFuZCBpc29sYXRlIHRoZSByZS1yZW5kZXIgYXQgdGhlIGN1c3RvbSBob29rIGxldmVsLiBJdCBoYXMgaXRzIHNjb3BlIGluIHRlcm1zIG9mIGZvcm0gc3RhdGUgc3Vic2NyaXB0aW9uLCBzbyBpdCB3b3VsZCBub3QgYWZmZWN0IG90aGVyIHVzZUZvcm1TdGF0ZSBhbmQgdXNlRm9ybS4gVXNpbmcgdGhpcyBob29rIGNhbiByZWR1Y2UgdGhlIHJlLXJlbmRlciBpbXBhY3Qgb24gbGFyZ2UgYW5kIGNvbXBsZXggZm9ybSBhcHBsaWNhdGlvbi5cbiAqXG4gKiBAcmVtYXJrc1xuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNlZm9ybXN0YXRlKSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy91c2Vmb3Jtc3RhdGUtNzV4bHkpXG4gKlxuICogQHBhcmFtIHByb3BzIC0gaW5jbHVkZSBvcHRpb25zIG9uIHNwZWNpZnkgZmllbGRzIHRvIHN1YnNjcmliZS4ge0BsaW5rIFVzZUZvcm1TdGF0ZVJldHVybn1cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IHsgcmVnaXN0ZXIsIGhhbmRsZVN1Ym1pdCwgY29udHJvbCB9ID0gdXNlRm9ybSh7XG4gKiAgICAgZGVmYXVsdFZhbHVlczoge1xuICogICAgIGZpcnN0TmFtZTogXCJmaXJzdE5hbWVcIlxuICogICB9fSk7XG4gKiAgIGNvbnN0IHsgZGlydHlGaWVsZHMgfSA9IHVzZUZvcm1TdGF0ZSh7XG4gKiAgICAgY29udHJvbFxuICogICB9KTtcbiAqICAgY29uc3Qgb25TdWJtaXQgPSAoZGF0YSkgPT4gY29uc29sZS5sb2coZGF0YSk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxmb3JtIG9uU3VibWl0PXtoYW5kbGVTdWJtaXQob25TdWJtaXQpfT5cbiAqICAgICAgIDxpbnB1dCB7Li4ucmVnaXN0ZXIoXCJmaXJzdE5hbWVcIil9IHBsYWNlaG9sZGVyPVwiRmlyc3QgTmFtZVwiIC8+XG4gKiAgICAgICB7ZGlydHlGaWVsZHMuZmlyc3ROYW1lICYmIDxwPkZpZWxkIGlzIGRpcnR5LjwvcD59XG4gKiAgICAgICA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiIC8+XG4gKiAgICAgPC9mb3JtPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZUZvcm1TdGF0ZShwcm9wcykge1xuICAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtQ29udGV4dCgpO1xuICAgIGNvbnN0IHsgY29udHJvbCA9IG1ldGhvZHMuY29udHJvbCwgZGlzYWJsZWQsIG5hbWUsIGV4YWN0IH0gPSBwcm9wcyB8fCB7fTtcbiAgICBjb25zdCBbZm9ybVN0YXRlLCB1cGRhdGVGb3JtU3RhdGVdID0gUmVhY3QudXNlU3RhdGUoY29udHJvbC5fZm9ybVN0YXRlKTtcbiAgICBjb25zdCBfbW91bnRlZCA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgICBjb25zdCBfbG9jYWxQcm94eUZvcm1TdGF0ZSA9IFJlYWN0LnVzZVJlZih7XG4gICAgICAgIGlzRGlydHk6IGZhbHNlLFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBkaXJ0eUZpZWxkczogZmFsc2UsXG4gICAgICAgIHRvdWNoZWRGaWVsZHM6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkYXRpbmc6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgZXJyb3JzOiBmYWxzZSxcbiAgICB9KTtcbiAgICBjb25zdCBfbmFtZSA9IFJlYWN0LnVzZVJlZihuYW1lKTtcbiAgICBfbmFtZS5jdXJyZW50ID0gbmFtZTtcbiAgICB1c2VTdWJzY3JpYmUoe1xuICAgICAgICBkaXNhYmxlZCxcbiAgICAgICAgbmV4dDogKHZhbHVlKSA9PiBfbW91bnRlZC5jdXJyZW50ICYmXG4gICAgICAgICAgICBzaG91bGRTdWJzY3JpYmVCeU5hbWUoX25hbWUuY3VycmVudCwgdmFsdWUubmFtZSwgZXhhY3QpICYmXG4gICAgICAgICAgICBzaG91bGRSZW5kZXJGb3JtU3RhdGUodmFsdWUsIF9sb2NhbFByb3h5Rm9ybVN0YXRlLmN1cnJlbnQsIGNvbnRyb2wuX3VwZGF0ZUZvcm1TdGF0ZSkgJiZcbiAgICAgICAgICAgIHVwZGF0ZUZvcm1TdGF0ZSh7XG4gICAgICAgICAgICAgICAgLi4uY29udHJvbC5fZm9ybVN0YXRlLFxuICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIHN1YmplY3Q6IGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLFxuICAgIH0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIF9tb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBfbG9jYWxQcm94eUZvcm1TdGF0ZS5jdXJyZW50LmlzVmFsaWQgJiYgY29udHJvbC5fdXBkYXRlVmFsaWQodHJ1ZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBfbW91bnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfSwgW2NvbnRyb2xdKTtcbiAgICByZXR1cm4gZ2V0UHJveHlGb3JtU3RhdGUoZm9ybVN0YXRlLCBjb250cm9sLCBfbG9jYWxQcm94eUZvcm1TdGF0ZS5jdXJyZW50LCBmYWxzZSk7XG59XG5cbnZhciBpc1N0cmluZyA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcblxudmFyIGdlbmVyYXRlV2F0Y2hPdXRwdXQgPSAobmFtZXMsIF9uYW1lcywgZm9ybVZhbHVlcywgaXNHbG9iYWwsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICAgIGlmIChpc1N0cmluZyhuYW1lcykpIHtcbiAgICAgICAgaXNHbG9iYWwgJiYgX25hbWVzLndhdGNoLmFkZChuYW1lcyk7XG4gICAgICAgIHJldHVybiBnZXQoZm9ybVZhbHVlcywgbmFtZXMsIGRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG5hbWVzKSkge1xuICAgICAgICByZXR1cm4gbmFtZXMubWFwKChmaWVsZE5hbWUpID0+IChpc0dsb2JhbCAmJiBfbmFtZXMud2F0Y2guYWRkKGZpZWxkTmFtZSksIGdldChmb3JtVmFsdWVzLCBmaWVsZE5hbWUpKSk7XG4gICAgfVxuICAgIGlzR2xvYmFsICYmIChfbmFtZXMud2F0Y2hBbGwgPSB0cnVlKTtcbiAgICByZXR1cm4gZm9ybVZhbHVlcztcbn07XG5cbi8qKlxuICogQ3VzdG9tIGhvb2sgdG8gc3Vic2NyaWJlIHRvIGZpZWxkIGNoYW5nZSBhbmQgaXNvbGF0ZSByZS1yZW5kZXJpbmcgYXQgdGhlIGNvbXBvbmVudCBsZXZlbC5cbiAqXG4gKiBAcmVtYXJrc1xuICpcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZXdhdGNoKSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tdjctdHMtdXNld2F0Y2gtaDlpNWUpXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogY29uc3QgeyBjb250cm9sIH0gPSB1c2VGb3JtKCk7XG4gKiBjb25zdCB2YWx1ZXMgPSB1c2VXYXRjaCh7XG4gKiAgIG5hbWU6IFwiZmllbGROYW1lXCJcbiAqICAgY29udHJvbCxcbiAqIH0pXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdXNlV2F0Y2gocHJvcHMpIHtcbiAgICBjb25zdCBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQoKTtcbiAgICBjb25zdCB7IGNvbnRyb2wgPSBtZXRob2RzLmNvbnRyb2wsIG5hbWUsIGRlZmF1bHRWYWx1ZSwgZGlzYWJsZWQsIGV4YWN0LCB9ID0gcHJvcHMgfHwge307XG4gICAgY29uc3QgX25hbWUgPSBSZWFjdC51c2VSZWYobmFtZSk7XG4gICAgX25hbWUuY3VycmVudCA9IG5hbWU7XG4gICAgdXNlU3Vic2NyaWJlKHtcbiAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgIHN1YmplY3Q6IGNvbnRyb2wuX3N1YmplY3RzLnZhbHVlcyxcbiAgICAgICAgbmV4dDogKGZvcm1TdGF0ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHNob3VsZFN1YnNjcmliZUJ5TmFtZShfbmFtZS5jdXJyZW50LCBmb3JtU3RhdGUubmFtZSwgZXhhY3QpKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlVmFsdWUoY2xvbmVPYmplY3QoZ2VuZXJhdGVXYXRjaE91dHB1dChfbmFtZS5jdXJyZW50LCBjb250cm9sLl9uYW1lcywgZm9ybVN0YXRlLnZhbHVlcyB8fCBjb250cm9sLl9mb3JtVmFsdWVzLCBmYWxzZSwgZGVmYXVsdFZhbHVlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IFt2YWx1ZSwgdXBkYXRlVmFsdWVdID0gUmVhY3QudXNlU3RhdGUoY29udHJvbC5fZ2V0V2F0Y2gobmFtZSwgZGVmYXVsdFZhbHVlKSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IGNvbnRyb2wuX3JlbW92ZVVubW91bnRlZCgpKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbnZhciBpc0tleSA9ICh2YWx1ZSkgPT4gL15cXHcqJC8udGVzdCh2YWx1ZSk7XG5cbnZhciBzdHJpbmdUb1BhdGggPSAoaW5wdXQpID0+IGNvbXBhY3QoaW5wdXQucmVwbGFjZSgvW1wifCddfFxcXS9nLCAnJykuc3BsaXQoL1xcLnxcXFsvKSk7XG5cbnZhciBzZXQgPSAob2JqZWN0LCBwYXRoLCB2YWx1ZSkgPT4ge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGNvbnN0IHRlbXBQYXRoID0gaXNLZXkocGF0aCkgPyBbcGF0aF0gOiBzdHJpbmdUb1BhdGgocGF0aCk7XG4gICAgY29uc3QgbGVuZ3RoID0gdGVtcFBhdGgubGVuZ3RoO1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGVtcFBhdGhbaW5kZXhdO1xuICAgICAgICBsZXQgbmV3VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICBuZXdWYWx1ZSA9XG4gICAgICAgICAgICAgICAgaXNPYmplY3Qob2JqVmFsdWUpIHx8IEFycmF5LmlzQXJyYXkob2JqVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiAhaXNOYU4oK3RlbXBQYXRoW2luZGV4ICsgMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHt9O1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdFtrZXldID0gbmV3VmFsdWU7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufTtcblxuLyoqXG4gKiBDdXN0b20gaG9vayB0byB3b3JrIHdpdGggY29udHJvbGxlZCBjb21wb25lbnQsIHRoaXMgZnVuY3Rpb24gcHJvdmlkZSB5b3Ugd2l0aCBib3RoIGZvcm0gYW5kIGZpZWxkIGxldmVsIHN0YXRlLiBSZS1yZW5kZXIgaXMgaXNvbGF0ZWQgYXQgdGhlIGhvb2sgbGV2ZWwuXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWNvbnRyb2xsZXIpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3VzZWNvbnRyb2xsZXItMG84cHgpXG4gKlxuICogQHBhcmFtIHByb3BzIC0gdGhlIHBhdGggbmFtZSB0byB0aGUgZm9ybSBmaWVsZCB2YWx1ZSwgYW5kIHZhbGlkYXRpb24gcnVsZXMuXG4gKlxuICogQHJldHVybnMgZmllbGQgcHJvcGVydGllcywgZmllbGQgYW5kIGZvcm0gc3RhdGUuIHtAbGluayBVc2VDb250cm9sbGVyUmV0dXJufVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGZ1bmN0aW9uIElucHV0KHByb3BzKSB7XG4gKiAgIGNvbnN0IHsgZmllbGQsIGZpZWxkU3RhdGUsIGZvcm1TdGF0ZSB9ID0gdXNlQ29udHJvbGxlcihwcm9wcyk7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGRpdj5cbiAqICAgICAgIDxpbnB1dCB7Li4uZmllbGR9IHBsYWNlaG9sZGVyPXtwcm9wcy5uYW1lfSAvPlxuICogICAgICAgPHA+e2ZpZWxkU3RhdGUuaXNUb3VjaGVkICYmIFwiVG91Y2hlZFwifTwvcD5cbiAqICAgICAgIDxwPntmb3JtU3RhdGUuaXNTdWJtaXR0ZWQgPyBcInN1Ym1pdHRlZFwiIDogXCJcIn08L3A+XG4gKiAgICAgPC9kaXY+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdXNlQ29udHJvbGxlcihwcm9wcykge1xuICAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtQ29udGV4dCgpO1xuICAgIGNvbnN0IHsgbmFtZSwgZGlzYWJsZWQsIGNvbnRyb2wgPSBtZXRob2RzLmNvbnRyb2wsIHNob3VsZFVucmVnaXN0ZXIgfSA9IHByb3BzO1xuICAgIGNvbnN0IGlzQXJyYXlGaWVsZCA9IGlzTmFtZUluRmllbGRBcnJheShjb250cm9sLl9uYW1lcy5hcnJheSwgbmFtZSk7XG4gICAgY29uc3QgdmFsdWUgPSB1c2VXYXRjaCh7XG4gICAgICAgIGNvbnRyb2wsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0KGNvbnRyb2wuX2Zvcm1WYWx1ZXMsIG5hbWUsIGdldChjb250cm9sLl9kZWZhdWx0VmFsdWVzLCBuYW1lLCBwcm9wcy5kZWZhdWx0VmFsdWUpKSxcbiAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgfSk7XG4gICAgY29uc3QgZm9ybVN0YXRlID0gdXNlRm9ybVN0YXRlKHtcbiAgICAgICAgY29udHJvbCxcbiAgICAgICAgbmFtZSxcbiAgICB9KTtcbiAgICBjb25zdCBfcmVnaXN0ZXJQcm9wcyA9IFJlYWN0LnVzZVJlZihjb250cm9sLnJlZ2lzdGVyKG5hbWUsIHtcbiAgICAgICAgLi4ucHJvcHMucnVsZXMsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICAuLi4oaXNCb29sZWFuKHByb3BzLmRpc2FibGVkKSA/IHsgZGlzYWJsZWQ6IHByb3BzLmRpc2FibGVkIH0gOiB7fSksXG4gICAgfSkpO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IF9zaG91bGRVbnJlZ2lzdGVyRmllbGQgPSBjb250cm9sLl9vcHRpb25zLnNob3VsZFVucmVnaXN0ZXIgfHwgc2hvdWxkVW5yZWdpc3RlcjtcbiAgICAgICAgY29uc3QgdXBkYXRlTW91bnRlZCA9IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoY29udHJvbC5fZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIGZpZWxkLl9mLm1vdW50ID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHVwZGF0ZU1vdW50ZWQobmFtZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChfc2hvdWxkVW5yZWdpc3RlckZpZWxkKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNsb25lT2JqZWN0KGdldChjb250cm9sLl9vcHRpb25zLmRlZmF1bHRWYWx1ZXMsIG5hbWUpKTtcbiAgICAgICAgICAgIHNldChjb250cm9sLl9kZWZhdWx0VmFsdWVzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoZ2V0KGNvbnRyb2wuX2Zvcm1WYWx1ZXMsIG5hbWUpKSkge1xuICAgICAgICAgICAgICAgIHNldChjb250cm9sLl9mb3JtVmFsdWVzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIChpc0FycmF5RmllbGRcbiAgICAgICAgICAgICAgICA/IF9zaG91bGRVbnJlZ2lzdGVyRmllbGQgJiYgIWNvbnRyb2wuX3N0YXRlLmFjdGlvblxuICAgICAgICAgICAgICAgIDogX3Nob3VsZFVucmVnaXN0ZXJGaWVsZClcbiAgICAgICAgICAgICAgICA/IGNvbnRyb2wudW5yZWdpc3RlcihuYW1lKVxuICAgICAgICAgICAgICAgIDogdXBkYXRlTW91bnRlZChuYW1lLCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgfSwgW25hbWUsIGNvbnRyb2wsIGlzQXJyYXlGaWVsZCwgc2hvdWxkVW5yZWdpc3Rlcl0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChnZXQoY29udHJvbC5fZmllbGRzLCBuYW1lKSkge1xuICAgICAgICAgICAgY29udHJvbC5fdXBkYXRlRGlzYWJsZWRGaWVsZCh7XG4gICAgICAgICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgZmllbGRzOiBjb250cm9sLl9maWVsZHMsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0KGNvbnRyb2wuX2ZpZWxkcywgbmFtZSkuX2YudmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtkaXNhYmxlZCwgbmFtZSwgY29udHJvbF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGZpZWxkOiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAuLi4oaXNCb29sZWFuKGRpc2FibGVkKSB8fCBmb3JtU3RhdGUuZGlzYWJsZWRcbiAgICAgICAgICAgICAgICA/IHsgZGlzYWJsZWQ6IGZvcm1TdGF0ZS5kaXNhYmxlZCB8fCBkaXNhYmxlZCB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICBvbkNoYW5nZTogUmVhY3QudXNlQ2FsbGJhY2soKGV2ZW50KSA9PiBfcmVnaXN0ZXJQcm9wcy5jdXJyZW50Lm9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdldEV2ZW50VmFsdWUoZXZlbnQpLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHlwZTogRVZFTlRTLkNIQU5HRSxcbiAgICAgICAgICAgIH0pLCBbbmFtZV0pLFxuICAgICAgICAgICAgb25CbHVyOiBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiBfcmVnaXN0ZXJQcm9wcy5jdXJyZW50Lm9uQmx1cih7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBnZXQoY29udHJvbC5fZm9ybVZhbHVlcywgbmFtZSksXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0eXBlOiBFVkVOVFMuQkxVUixcbiAgICAgICAgICAgIH0pLCBbbmFtZSwgY29udHJvbF0pLFxuICAgICAgICAgICAgcmVmOiAoZWxtKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoY29udHJvbC5fZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQgJiYgZWxtKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLl9mLnJlZiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzOiAoKSA9PiBlbG0uZm9jdXMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdDogKCkgPT4gZWxtLnNlbGVjdCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHk6IChtZXNzYWdlKSA9PiBlbG0uc2V0Q3VzdG9tVmFsaWRpdHkobWVzc2FnZSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBvcnRWYWxpZGl0eTogKCkgPT4gZWxtLnJlcG9ydFZhbGlkaXR5KCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybVN0YXRlLFxuICAgICAgICBmaWVsZFN0YXRlOiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh7fSwge1xuICAgICAgICAgICAgaW52YWxpZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiAhIWdldChmb3JtU3RhdGUuZXJyb3JzLCBuYW1lKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0RpcnR5OiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+ICEhZ2V0KGZvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNUb3VjaGVkOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+ICEhZ2V0KGZvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBnZXQoZm9ybVN0YXRlLmVycm9ycywgbmFtZSksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSxcbiAgICB9O1xufVxuXG4vKipcbiAqIENvbXBvbmVudCBiYXNlZCBvbiBgdXNlQ29udHJvbGxlcmAgaG9vayB0byB3b3JrIHdpdGggY29udHJvbGxlZCBjb21wb25lbnQuXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWNvbnRyb2xsZXIvY29udHJvbGxlcikg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvcmVhY3QtaG9vay1mb3JtLXY2LWNvbnRyb2xsZXItdHMtand5encpIOKAoiBbVmlkZW9dKGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9TjJVTmtfVUNWeUEpXG4gKlxuICogQHBhcmFtIHByb3BzIC0gdGhlIHBhdGggbmFtZSB0byB0aGUgZm9ybSBmaWVsZCB2YWx1ZSwgYW5kIHZhbGlkYXRpb24gcnVsZXMuXG4gKlxuICogQHJldHVybnMgcHJvdmlkZSBmaWVsZCBoYW5kbGVyIGZ1bmN0aW9ucywgZmllbGQgYW5kIGZvcm0gc3RhdGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCB7IGNvbnRyb2wgfSA9IHVzZUZvcm08Rm9ybVZhbHVlcz4oe1xuICogICAgIGRlZmF1bHRWYWx1ZXM6IHtcbiAqICAgICAgIHRlc3Q6IFwiXCJcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Zm9ybT5cbiAqICAgICAgIDxDb250cm9sbGVyXG4gKiAgICAgICAgIGNvbnRyb2w9e2NvbnRyb2x9XG4gKiAgICAgICAgIG5hbWU9XCJ0ZXN0XCJcbiAqICAgICAgICAgcmVuZGVyPXsoeyBmaWVsZDogeyBvbkNoYW5nZSwgb25CbHVyLCB2YWx1ZSwgcmVmIH0sIGZvcm1TdGF0ZSwgZmllbGRTdGF0ZSB9KSA9PiAoXG4gKiAgICAgICAgICAgPD5cbiAqICAgICAgICAgICAgIDxpbnB1dFxuICogICAgICAgICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2V9IC8vIHNlbmQgdmFsdWUgdG8gaG9vayBmb3JtXG4gKiAgICAgICAgICAgICAgIG9uQmx1cj17b25CbHVyfSAvLyBub3RpZnkgd2hlbiBpbnB1dCBpcyB0b3VjaGVkXG4gKiAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX0gLy8gcmV0dXJuIHVwZGF0ZWQgdmFsdWVcbiAqICAgICAgICAgICAgICAgcmVmPXtyZWZ9IC8vIHNldCByZWYgZm9yIGZvY3VzIG1hbmFnZW1lbnRcbiAqICAgICAgICAgICAgIC8+XG4gKiAgICAgICAgICAgICA8cD57Zm9ybVN0YXRlLmlzU3VibWl0dGVkID8gXCJzdWJtaXR0ZWRcIiA6IFwiXCJ9PC9wPlxuICogICAgICAgICAgICAgPHA+e2ZpZWxkU3RhdGUuaXNUb3VjaGVkID8gXCJ0b3VjaGVkXCIgOiBcIlwifTwvcD5cbiAqICAgICAgICAgICA8Lz5cbiAqICAgICAgICAgKX1cbiAqICAgICAgIC8+XG4gKiAgICAgPC9mb3JtPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmNvbnN0IENvbnRyb2xsZXIgPSAocHJvcHMpID0+IHByb3BzLnJlbmRlcih1c2VDb250cm9sbGVyKHByb3BzKSk7XG5cbmNvbnN0IFBPU1RfUkVRVUVTVCA9ICdwb3N0Jztcbi8qKlxuICogRm9ybSBjb21wb25lbnQgdG8gbWFuYWdlIHN1Ym1pc3Npb24uXG4gKlxuICogQHBhcmFtIHByb3BzIC0gdG8gc2V0dXAgc3VibWlzc2lvbiBkZXRhaWwuIHtAbGluayBGb3JtUHJvcHN9XG4gKlxuICogQHJldHVybnMgZm9ybSBjb21wb25lbnQgb3IgaGVhZGxlc3MgcmVuZGVyIHByb3AuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCB7IGNvbnRyb2wsIGZvcm1TdGF0ZTogeyBlcnJvcnMgfSB9ID0gdXNlRm9ybSgpO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Rm9ybSBhY3Rpb249XCIvYXBpXCIgY29udHJvbD17Y29udHJvbH0+XG4gKiAgICAgICA8aW5wdXQgey4uLnJlZ2lzdGVyKFwibmFtZVwiKX0gLz5cbiAqICAgICAgIDxwPntlcnJvcnM/LnJvb3Q/LnNlcnZlciAmJiAnU2VydmVyIGVycm9yJ308L3A+XG4gKiAgICAgICA8YnV0dG9uPlN1Ym1pdDwvYnV0dG9uPlxuICogICAgIDwvRm9ybT5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBGb3JtKHByb3BzKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IHVzZUZvcm1Db250ZXh0KCk7XG4gICAgY29uc3QgW21vdW50ZWQsIHNldE1vdW50ZWRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHsgY29udHJvbCA9IG1ldGhvZHMuY29udHJvbCwgb25TdWJtaXQsIGNoaWxkcmVuLCBhY3Rpb24sIG1ldGhvZCA9IFBPU1RfUkVRVUVTVCwgaGVhZGVycywgZW5jVHlwZSwgb25FcnJvciwgcmVuZGVyLCBvblN1Y2Nlc3MsIHZhbGlkYXRlU3RhdHVzLCAuLi5yZXN0IH0gPSBwcm9wcztcbiAgICBjb25zdCBzdWJtaXQgPSBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgbGV0IGhhc0Vycm9yID0gZmFsc2U7XG4gICAgICAgIGxldCB0eXBlID0gJyc7XG4gICAgICAgIGF3YWl0IGNvbnRyb2wuaGFuZGxlU3VibWl0KGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgICAgbGV0IGZvcm1EYXRhSnNvbiA9ICcnO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YUpzb24gPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgY29udHJvbC5fbmFtZXMubW91bnQpIHtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgZ2V0KGRhdGEsIG5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblN1Ym1pdCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG9uU3VibWl0KHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhSnNvbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRTdHJpbmdpZnlTdWJtaXNzaW9uRGF0YSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnMgJiYgaGVhZGVyc1snQ29udGVudC1UeXBlJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNUeXBlLFxuICAgICAgICAgICAgICAgICAgICBdLnNvbWUoKHZhbHVlKSA9PiB2YWx1ZSAmJiB2YWx1ZS5pbmNsdWRlcygnanNvbicpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhY3Rpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLihlbmNUeXBlID8geyAnQ29udGVudC1UeXBlJzogZW5jVHlwZSB9IDoge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHNob3VsZFN0cmluZ2lmeVN1Ym1pc3Npb25EYXRhID8gZm9ybURhdGFKc29uIDogZm9ybURhdGEsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICh2YWxpZGF0ZVN0YXR1c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gIXZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJlc3BvbnNlLnN0YXR1cyA8IDIwMCB8fCByZXNwb25zZS5zdGF0dXMgPj0gMzAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvciAmJiBvbkVycm9yKHsgcmVzcG9uc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gU3RyaW5nKHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3MgJiYgb25TdWNjZXNzKHsgcmVzcG9uc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvciAmJiBvbkVycm9yKHsgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KShldmVudCk7XG4gICAgICAgIGlmIChoYXNFcnJvciAmJiBwcm9wcy5jb250cm9sKSB7XG4gICAgICAgICAgICBwcm9wcy5jb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICBpc1N1Ym1pdFN1Y2Nlc3NmdWw6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9wcy5jb250cm9sLnNldEVycm9yKCdyb290LnNlcnZlcicsIHtcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldE1vdW50ZWQodHJ1ZSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiByZW5kZXIgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgcmVuZGVyKHtcbiAgICAgICAgc3VibWl0LFxuICAgIH0pKSkgOiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImZvcm1cIiwgeyBub1ZhbGlkYXRlOiBtb3VudGVkLCBhY3Rpb246IGFjdGlvbiwgbWV0aG9kOiBtZXRob2QsIGVuY1R5cGU6IGVuY1R5cGUsIG9uU3VibWl0OiBzdWJtaXQsIC4uLnJlc3QgfSwgY2hpbGRyZW4pKTtcbn1cblxudmFyIGFwcGVuZEVycm9ycyA9IChuYW1lLCB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIGVycm9ycywgdHlwZSwgbWVzc2FnZSkgPT4gdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhXG4gICAgPyB7XG4gICAgICAgIC4uLmVycm9yc1tuYW1lXSxcbiAgICAgICAgdHlwZXM6IHtcbiAgICAgICAgICAgIC4uLihlcnJvcnNbbmFtZV0gJiYgZXJyb3JzW25hbWVdLnR5cGVzID8gZXJyb3JzW25hbWVdLnR5cGVzIDoge30pLFxuICAgICAgICAgICAgW3R5cGVdOiBtZXNzYWdlIHx8IHRydWUsXG4gICAgICAgIH0sXG4gICAgfVxuICAgIDoge307XG5cbnZhciBnZW5lcmF0ZUlkID0gKCkgPT4ge1xuICAgIGNvbnN0IGQgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICd1bmRlZmluZWQnID8gRGF0ZS5ub3coKSA6IHBlcmZvcm1hbmNlLm5vdygpICogMTAwMDtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCAoYykgPT4ge1xuICAgICAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNiArIGQpICUgMTYgfCAwO1xuICAgICAgICByZXR1cm4gKGMgPT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4OCkudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xufTtcblxudmFyIGdldEZvY3VzRmllbGROYW1lID0gKG5hbWUsIGluZGV4LCBvcHRpb25zID0ge30pID0+IG9wdGlvbnMuc2hvdWxkRm9jdXMgfHwgaXNVbmRlZmluZWQob3B0aW9ucy5zaG91bGRGb2N1cylcbiAgICA/IG9wdGlvbnMuZm9jdXNOYW1lIHx8XG4gICAgICAgIGAke25hbWV9LiR7aXNVbmRlZmluZWQob3B0aW9ucy5mb2N1c0luZGV4KSA/IGluZGV4IDogb3B0aW9ucy5mb2N1c0luZGV4fS5gXG4gICAgOiAnJztcblxudmFyIGdldFZhbGlkYXRpb25Nb2RlcyA9IChtb2RlKSA9PiAoe1xuICAgIGlzT25TdWJtaXQ6ICFtb2RlIHx8IG1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5vblN1Ym1pdCxcbiAgICBpc09uQmx1cjogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLm9uQmx1cixcbiAgICBpc09uQ2hhbmdlOiBtb2RlID09PSBWQUxJREFUSU9OX01PREUub25DaGFuZ2UsXG4gICAgaXNPbkFsbDogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLmFsbCxcbiAgICBpc09uVG91Y2g6IG1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5vblRvdWNoZWQsXG59KTtcblxudmFyIGlzV2F0Y2hlZCA9IChuYW1lLCBfbmFtZXMsIGlzQmx1ckV2ZW50KSA9PiAhaXNCbHVyRXZlbnQgJiZcbiAgICAoX25hbWVzLndhdGNoQWxsIHx8XG4gICAgICAgIF9uYW1lcy53YXRjaC5oYXMobmFtZSkgfHxcbiAgICAgICAgWy4uLl9uYW1lcy53YXRjaF0uc29tZSgod2F0Y2hOYW1lKSA9PiBuYW1lLnN0YXJ0c1dpdGgod2F0Y2hOYW1lKSAmJlxuICAgICAgICAgICAgL15cXC5cXHcrLy50ZXN0KG5hbWUuc2xpY2Uod2F0Y2hOYW1lLmxlbmd0aCkpKSk7XG5cbmNvbnN0IGl0ZXJhdGVGaWVsZHNCeUFjdGlvbiA9IChmaWVsZHMsIGFjdGlvbiwgZmllbGRzTmFtZXMsIGFib3J0RWFybHkpID0+IHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBmaWVsZHNOYW1lcyB8fCBPYmplY3Qua2V5cyhmaWVsZHMpKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KGZpZWxkcywga2V5KTtcbiAgICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgICAgICBjb25zdCB7IF9mLCAuLi5jdXJyZW50RmllbGQgfSA9IGZpZWxkO1xuICAgICAgICAgICAgaWYgKF9mKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9mLnJlZnMgJiYgX2YucmVmc1swXSAmJiBhY3Rpb24oX2YucmVmc1swXSwga2V5KSAmJiAhYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX2YucmVmICYmIGFjdGlvbihfZi5yZWYsIF9mLm5hbWUpICYmICFhYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZUZpZWxkc0J5QWN0aW9uKGN1cnJlbnRGaWVsZCwgYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc09iamVjdChjdXJyZW50RmllbGQpKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0ZUZpZWxkc0J5QWN0aW9uKGN1cnJlbnRGaWVsZCwgYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciB1cGRhdGVGaWVsZEFycmF5Um9vdEVycm9yID0gKGVycm9ycywgZXJyb3IsIG5hbWUpID0+IHtcbiAgICBjb25zdCBmaWVsZEFycmF5RXJyb3JzID0gY29tcGFjdChnZXQoZXJyb3JzLCBuYW1lKSk7XG4gICAgc2V0KGZpZWxkQXJyYXlFcnJvcnMsICdyb290JywgZXJyb3JbbmFtZV0pO1xuICAgIHNldChlcnJvcnMsIG5hbWUsIGZpZWxkQXJyYXlFcnJvcnMpO1xuICAgIHJldHVybiBlcnJvcnM7XG59O1xuXG52YXIgaXNGaWxlSW5wdXQgPSAoZWxlbWVudCkgPT4gZWxlbWVudC50eXBlID09PSAnZmlsZSc7XG5cbnZhciBpc0Z1bmN0aW9uID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG5cbnZhciBpc0hUTUxFbGVtZW50ID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFpc1dlYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG93bmVyID0gdmFsdWUgPyB2YWx1ZS5vd25lckRvY3VtZW50IDogMDtcbiAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2ZcbiAgICAgICAgKG93bmVyICYmIG93bmVyLmRlZmF1bHRWaWV3ID8gb3duZXIuZGVmYXVsdFZpZXcuSFRNTEVsZW1lbnQgOiBIVE1MRWxlbWVudCkpO1xufTtcblxudmFyIGlzTWVzc2FnZSA9ICh2YWx1ZSkgPT4gaXNTdHJpbmcodmFsdWUpO1xuXG52YXIgaXNSYWRpb0lucHV0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gJ3JhZGlvJztcblxudmFyIGlzUmVnZXggPSAodmFsdWUpID0+IHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwO1xuXG5jb25zdCBkZWZhdWx0UmVzdWx0ID0ge1xuICAgIHZhbHVlOiBmYWxzZSxcbiAgICBpc1ZhbGlkOiBmYWxzZSxcbn07XG5jb25zdCB2YWxpZFJlc3VsdCA9IHsgdmFsdWU6IHRydWUsIGlzVmFsaWQ6IHRydWUgfTtcbnZhciBnZXRDaGVja2JveFZhbHVlID0gKG9wdGlvbnMpID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBvcHRpb25zXG4gICAgICAgICAgICAgICAgLmZpbHRlcigob3B0aW9uKSA9PiBvcHRpb24gJiYgb3B0aW9uLmNoZWNrZWQgJiYgIW9wdGlvbi5kaXNhYmxlZClcbiAgICAgICAgICAgICAgICAubWFwKChvcHRpb24pID0+IG9wdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWVzLCBpc1ZhbGlkOiAhIXZhbHVlcy5sZW5ndGggfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9uc1swXS5jaGVja2VkICYmICFvcHRpb25zWzBdLmRpc2FibGVkXG4gICAgICAgICAgICA/IC8vIEB0cy1leHBlY3QtZXJyb3IgZXhwZWN0ZWQgdG8gd29yayBpbiB0aGUgYnJvd3NlclxuICAgICAgICAgICAgICAgIG9wdGlvbnNbMF0uYXR0cmlidXRlcyAmJiAhaXNVbmRlZmluZWQob3B0aW9uc1swXS5hdHRyaWJ1dGVzLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA/IGlzVW5kZWZpbmVkKG9wdGlvbnNbMF0udmFsdWUpIHx8IG9wdGlvbnNbMF0udmFsdWUgPT09ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHZhbGlkUmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHsgdmFsdWU6IG9wdGlvbnNbMF0udmFsdWUsIGlzVmFsaWQ6IHRydWUgfVxuICAgICAgICAgICAgICAgICAgICA6IHZhbGlkUmVzdWx0XG4gICAgICAgICAgICA6IGRlZmF1bHRSZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0UmVzdWx0O1xufTtcblxuY29uc3QgZGVmYXVsdFJldHVybiA9IHtcbiAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICB2YWx1ZTogbnVsbCxcbn07XG52YXIgZ2V0UmFkaW9WYWx1ZSA9IChvcHRpb25zKSA9PiBBcnJheS5pc0FycmF5KG9wdGlvbnMpXG4gICAgPyBvcHRpb25zLnJlZHVjZSgocHJldmlvdXMsIG9wdGlvbikgPT4gb3B0aW9uICYmIG9wdGlvbi5jaGVja2VkICYmICFvcHRpb24uZGlzYWJsZWRcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBpc1ZhbGlkOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG9wdGlvbi52YWx1ZSxcbiAgICAgICAgfVxuICAgICAgICA6IHByZXZpb3VzLCBkZWZhdWx0UmV0dXJuKVxuICAgIDogZGVmYXVsdFJldHVybjtcblxuZnVuY3Rpb24gZ2V0VmFsaWRhdGVFcnJvcihyZXN1bHQsIHJlZiwgdHlwZSA9ICd2YWxpZGF0ZScpIHtcbiAgICBpZiAoaXNNZXNzYWdlKHJlc3VsdCkgfHxcbiAgICAgICAgKEFycmF5LmlzQXJyYXkocmVzdWx0KSAmJiByZXN1bHQuZXZlcnkoaXNNZXNzYWdlKSkgfHxcbiAgICAgICAgKGlzQm9vbGVhbihyZXN1bHQpICYmICFyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbWVzc2FnZTogaXNNZXNzYWdlKHJlc3VsdCkgPyByZXN1bHQgOiAnJyxcbiAgICAgICAgICAgIHJlZixcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbnZhciBnZXRWYWx1ZUFuZE1lc3NhZ2UgPSAodmFsaWRhdGlvbkRhdGEpID0+IGlzT2JqZWN0KHZhbGlkYXRpb25EYXRhKSAmJiAhaXNSZWdleCh2YWxpZGF0aW9uRGF0YSlcbiAgICA/IHZhbGlkYXRpb25EYXRhXG4gICAgOiB7XG4gICAgICAgIHZhbHVlOiB2YWxpZGF0aW9uRGF0YSxcbiAgICAgICAgbWVzc2FnZTogJycsXG4gICAgfTtcblxudmFyIHZhbGlkYXRlRmllbGQgPSBhc3luYyAoZmllbGQsIGZvcm1WYWx1ZXMsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiwgaXNGaWVsZEFycmF5KSA9PiB7XG4gICAgY29uc3QgeyByZWYsIHJlZnMsIHJlcXVpcmVkLCBtYXhMZW5ndGgsIG1pbkxlbmd0aCwgbWluLCBtYXgsIHBhdHRlcm4sIHZhbGlkYXRlLCBuYW1lLCB2YWx1ZUFzTnVtYmVyLCBtb3VudCwgZGlzYWJsZWQsIH0gPSBmaWVsZC5fZjtcbiAgICBjb25zdCBpbnB1dFZhbHVlID0gZ2V0KGZvcm1WYWx1ZXMsIG5hbWUpO1xuICAgIGlmICghbW91bnQgfHwgZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBpbnB1dFJlZiA9IHJlZnMgPyByZWZzWzBdIDogcmVmO1xuICAgIGNvbnN0IHNldEN1c3RvbVZhbGlkaXR5ID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgaWYgKHNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24gJiYgaW5wdXRSZWYucmVwb3J0VmFsaWRpdHkpIHtcbiAgICAgICAgICAgIGlucHV0UmVmLnNldEN1c3RvbVZhbGlkaXR5KGlzQm9vbGVhbihtZXNzYWdlKSA/ICcnIDogbWVzc2FnZSB8fCAnJyk7XG4gICAgICAgICAgICBpbnB1dFJlZi5yZXBvcnRWYWxpZGl0eSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBlcnJvciA9IHt9O1xuICAgIGNvbnN0IGlzUmFkaW8gPSBpc1JhZGlvSW5wdXQocmVmKTtcbiAgICBjb25zdCBpc0NoZWNrQm94ID0gaXNDaGVja0JveElucHV0KHJlZik7XG4gICAgY29uc3QgaXNSYWRpb09yQ2hlY2tib3ggPSBpc1JhZGlvIHx8IGlzQ2hlY2tCb3g7XG4gICAgY29uc3QgaXNFbXB0eSA9ICgodmFsdWVBc051bWJlciB8fCBpc0ZpbGVJbnB1dChyZWYpKSAmJlxuICAgICAgICBpc1VuZGVmaW5lZChyZWYudmFsdWUpICYmXG4gICAgICAgIGlzVW5kZWZpbmVkKGlucHV0VmFsdWUpKSB8fFxuICAgICAgICAoaXNIVE1MRWxlbWVudChyZWYpICYmIHJlZi52YWx1ZSA9PT0gJycpIHx8XG4gICAgICAgIGlucHV0VmFsdWUgPT09ICcnIHx8XG4gICAgICAgIChBcnJheS5pc0FycmF5KGlucHV0VmFsdWUpICYmICFpbnB1dFZhbHVlLmxlbmd0aCk7XG4gICAgY29uc3QgYXBwZW5kRXJyb3JzQ3VycnkgPSBhcHBlbmRFcnJvcnMuYmluZChudWxsLCBuYW1lLCB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIGVycm9yKTtcbiAgICBjb25zdCBnZXRNaW5NYXhNZXNzYWdlID0gKGV4Y2VlZE1heCwgbWF4TGVuZ3RoTWVzc2FnZSwgbWluTGVuZ3RoTWVzc2FnZSwgbWF4VHlwZSA9IElOUFVUX1ZBTElEQVRJT05fUlVMRVMubWF4TGVuZ3RoLCBtaW5UeXBlID0gSU5QVVRfVkFMSURBVElPTl9SVUxFUy5taW5MZW5ndGgpID0+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGV4Y2VlZE1heCA/IG1heExlbmd0aE1lc3NhZ2UgOiBtaW5MZW5ndGhNZXNzYWdlO1xuICAgICAgICBlcnJvcltuYW1lXSA9IHtcbiAgICAgICAgICAgIHR5cGU6IGV4Y2VlZE1heCA/IG1heFR5cGUgOiBtaW5UeXBlLFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgIC4uLmFwcGVuZEVycm9yc0N1cnJ5KGV4Y2VlZE1heCA/IG1heFR5cGUgOiBtaW5UeXBlLCBtZXNzYWdlKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGlmIChpc0ZpZWxkQXJyYXlcbiAgICAgICAgPyAhQXJyYXkuaXNBcnJheShpbnB1dFZhbHVlKSB8fCAhaW5wdXRWYWx1ZS5sZW5ndGhcbiAgICAgICAgOiByZXF1aXJlZCAmJlxuICAgICAgICAgICAgKCghaXNSYWRpb09yQ2hlY2tib3ggJiYgKGlzRW1wdHkgfHwgaXNOdWxsT3JVbmRlZmluZWQoaW5wdXRWYWx1ZSkpKSB8fFxuICAgICAgICAgICAgICAgIChpc0Jvb2xlYW4oaW5wdXRWYWx1ZSkgJiYgIWlucHV0VmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgKGlzQ2hlY2tCb3ggJiYgIWdldENoZWNrYm94VmFsdWUocmVmcykuaXNWYWxpZCkgfHxcbiAgICAgICAgICAgICAgICAoaXNSYWRpbyAmJiAhZ2V0UmFkaW9WYWx1ZShyZWZzKS5pc1ZhbGlkKSkpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgbWVzc2FnZSB9ID0gaXNNZXNzYWdlKHJlcXVpcmVkKVxuICAgICAgICAgICAgPyB7IHZhbHVlOiAhIXJlcXVpcmVkLCBtZXNzYWdlOiByZXF1aXJlZCB9XG4gICAgICAgICAgICA6IGdldFZhbHVlQW5kTWVzc2FnZShyZXF1aXJlZCk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgZXJyb3JbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogSU5QVVRfVkFMSURBVElPTl9SVUxFUy5yZXF1aXJlZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIHJlZjogaW5wdXRSZWYsXG4gICAgICAgICAgICAgICAgLi4uYXBwZW5kRXJyb3JzQ3VycnkoSU5QVVRfVkFMSURBVElPTl9SVUxFUy5yZXF1aXJlZCwgbWVzc2FnZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICBzZXRDdXN0b21WYWxpZGl0eShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc0VtcHR5ICYmICghaXNOdWxsT3JVbmRlZmluZWQobWluKSB8fCAhaXNOdWxsT3JVbmRlZmluZWQobWF4KSkpIHtcbiAgICAgICAgbGV0IGV4Y2VlZE1heDtcbiAgICAgICAgbGV0IGV4Y2VlZE1pbjtcbiAgICAgICAgY29uc3QgbWF4T3V0cHV0ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKG1heCk7XG4gICAgICAgIGNvbnN0IG1pbk91dHB1dCA9IGdldFZhbHVlQW5kTWVzc2FnZShtaW4pO1xuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGlucHV0VmFsdWUpICYmICFpc05hTihpbnB1dFZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVOdW1iZXIgPSByZWYudmFsdWVBc051bWJlciB8fFxuICAgICAgICAgICAgICAgIChpbnB1dFZhbHVlID8gK2lucHV0VmFsdWUgOiBpbnB1dFZhbHVlKTtcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQobWF4T3V0cHV0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGV4Y2VlZE1heCA9IHZhbHVlTnVtYmVyID4gbWF4T3V0cHV0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChtaW5PdXRwdXQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZXhjZWVkTWluID0gdmFsdWVOdW1iZXIgPCBtaW5PdXRwdXQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZURhdGUgPSByZWYudmFsdWVBc0RhdGUgfHwgbmV3IERhdGUoaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBjb252ZXJ0VGltZVRvRGF0ZSA9ICh0aW1lKSA9PiBuZXcgRGF0ZShuZXcgRGF0ZSgpLnRvRGF0ZVN0cmluZygpICsgJyAnICsgdGltZSk7XG4gICAgICAgICAgICBjb25zdCBpc1RpbWUgPSByZWYudHlwZSA9PSAndGltZSc7XG4gICAgICAgICAgICBjb25zdCBpc1dlZWsgPSByZWYudHlwZSA9PSAnd2Vlayc7XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcobWF4T3V0cHV0LnZhbHVlKSAmJiBpbnB1dFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZXhjZWVkTWF4ID0gaXNUaW1lXG4gICAgICAgICAgICAgICAgICAgID8gY29udmVydFRpbWVUb0RhdGUoaW5wdXRWYWx1ZSkgPiBjb252ZXJ0VGltZVRvRGF0ZShtYXhPdXRwdXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIDogaXNXZWVrXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGlucHV0VmFsdWUgPiBtYXhPdXRwdXQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWVEYXRlID4gbmV3IERhdGUobWF4T3V0cHV0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhtaW5PdXRwdXQudmFsdWUpICYmIGlucHV0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBleGNlZWRNaW4gPSBpc1RpbWVcbiAgICAgICAgICAgICAgICAgICAgPyBjb252ZXJ0VGltZVRvRGF0ZShpbnB1dFZhbHVlKSA8IGNvbnZlcnRUaW1lVG9EYXRlKG1pbk91dHB1dC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgOiBpc1dlZWtcbiAgICAgICAgICAgICAgICAgICAgICAgID8gaW5wdXRWYWx1ZSA8IG1pbk91dHB1dC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZURhdGUgPCBuZXcgRGF0ZShtaW5PdXRwdXQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleGNlZWRNYXggfHwgZXhjZWVkTWluKSB7XG4gICAgICAgICAgICBnZXRNaW5NYXhNZXNzYWdlKCEhZXhjZWVkTWF4LCBtYXhPdXRwdXQubWVzc2FnZSwgbWluT3V0cHV0Lm1lc3NhZ2UsIElOUFVUX1ZBTElEQVRJT05fUlVMRVMubWF4LCBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLm1pbik7XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KGVycm9yW25hbWVdLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoKG1heExlbmd0aCB8fCBtaW5MZW5ndGgpICYmXG4gICAgICAgICFpc0VtcHR5ICYmXG4gICAgICAgIChpc1N0cmluZyhpbnB1dFZhbHVlKSB8fCAoaXNGaWVsZEFycmF5ICYmIEFycmF5LmlzQXJyYXkoaW5wdXRWYWx1ZSkpKSkge1xuICAgICAgICBjb25zdCBtYXhMZW5ndGhPdXRwdXQgPSBnZXRWYWx1ZUFuZE1lc3NhZ2UobWF4TGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbWluTGVuZ3RoT3V0cHV0ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKG1pbkxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGV4Y2VlZE1heCA9ICFpc051bGxPclVuZGVmaW5lZChtYXhMZW5ndGhPdXRwdXQudmFsdWUpICYmXG4gICAgICAgICAgICBpbnB1dFZhbHVlLmxlbmd0aCA+ICttYXhMZW5ndGhPdXRwdXQudmFsdWU7XG4gICAgICAgIGNvbnN0IGV4Y2VlZE1pbiA9ICFpc051bGxPclVuZGVmaW5lZChtaW5MZW5ndGhPdXRwdXQudmFsdWUpICYmXG4gICAgICAgICAgICBpbnB1dFZhbHVlLmxlbmd0aCA8ICttaW5MZW5ndGhPdXRwdXQudmFsdWU7XG4gICAgICAgIGlmIChleGNlZWRNYXggfHwgZXhjZWVkTWluKSB7XG4gICAgICAgICAgICBnZXRNaW5NYXhNZXNzYWdlKGV4Y2VlZE1heCwgbWF4TGVuZ3RoT3V0cHV0Lm1lc3NhZ2UsIG1pbkxlbmd0aE91dHB1dC5tZXNzYWdlKTtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHkoZXJyb3JbbmFtZV0ubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXR0ZXJuICYmICFpc0VtcHR5ICYmIGlzU3RyaW5nKGlucHV0VmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWU6IHBhdHRlcm5WYWx1ZSwgbWVzc2FnZSB9ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKHBhdHRlcm4pO1xuICAgICAgICBpZiAoaXNSZWdleChwYXR0ZXJuVmFsdWUpICYmICFpbnB1dFZhbHVlLm1hdGNoKHBhdHRlcm5WYWx1ZSkpIHtcbiAgICAgICAgICAgIGVycm9yW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IElOUFVUX1ZBTElEQVRJT05fUlVMRVMucGF0dGVybixcbiAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgICAgICAuLi5hcHBlbmRFcnJvcnNDdXJyeShJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnBhdHRlcm4sIG1lc3NhZ2UpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHkobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh2YWxpZGF0ZSkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWxpZGF0ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlKGlucHV0VmFsdWUsIGZvcm1WYWx1ZXMpO1xuICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVFcnJvciA9IGdldFZhbGlkYXRlRXJyb3IocmVzdWx0LCBpbnB1dFJlZik7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGVFcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9yW25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi52YWxpZGF0ZUVycm9yLFxuICAgICAgICAgICAgICAgICAgICAuLi5hcHBlbmRFcnJvcnNDdXJyeShJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnZhbGlkYXRlLCB2YWxpZGF0ZUVycm9yLm1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHkodmFsaWRhdGVFcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09iamVjdCh2YWxpZGF0ZSkpIHtcbiAgICAgICAgICAgIGxldCB2YWxpZGF0aW9uUmVzdWx0ID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eU9iamVjdCh2YWxpZGF0aW9uUmVzdWx0KSAmJiAhdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0ZUVycm9yID0gZ2V0VmFsaWRhdGVFcnJvcihhd2FpdCB2YWxpZGF0ZVtrZXldKGlucHV0VmFsdWUsIGZvcm1WYWx1ZXMpLCBpbnB1dFJlZiwga2V5KTtcbiAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udmFsaWRhdGVFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmFwcGVuZEVycm9yc0N1cnJ5KGtleSwgdmFsaWRhdGVFcnJvci5tZXNzYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHkodmFsaWRhdGVFcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JbbmFtZV0gPSB2YWxpZGF0aW9uUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0VtcHR5T2JqZWN0KHZhbGlkYXRpb25SZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjogaW5wdXRSZWYsXG4gICAgICAgICAgICAgICAgICAgIC4uLnZhbGlkYXRpb25SZXN1bHQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldEN1c3RvbVZhbGlkaXR5KHRydWUpO1xuICAgIHJldHVybiBlcnJvcjtcbn07XG5cbnZhciBhcHBlbmRBdCA9IChkYXRhLCB2YWx1ZSkgPT4gW1xuICAgIC4uLmRhdGEsXG4gICAgLi4uY29udmVydFRvQXJyYXlQYXlsb2FkKHZhbHVlKSxcbl07XG5cbnZhciBmaWxsRW1wdHlBcnJheSA9ICh2YWx1ZSkgPT4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAoKCkgPT4gdW5kZWZpbmVkKSA6IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaW5zZXJ0KGRhdGEsIGluZGV4LCB2YWx1ZSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIC4uLmRhdGEuc2xpY2UoMCwgaW5kZXgpLFxuICAgICAgICAuLi5jb252ZXJ0VG9BcnJheVBheWxvYWQodmFsdWUpLFxuICAgICAgICAuLi5kYXRhLnNsaWNlKGluZGV4KSxcbiAgICBdO1xufVxuXG52YXIgbW92ZUFycmF5QXQgPSAoZGF0YSwgZnJvbSwgdG8pID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoaXNVbmRlZmluZWQoZGF0YVt0b10pKSB7XG4gICAgICAgIGRhdGFbdG9dID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBkYXRhLnNwbGljZSh0bywgMCwgZGF0YS5zcGxpY2UoZnJvbSwgMSlbMF0pO1xuICAgIHJldHVybiBkYXRhO1xufTtcblxudmFyIHByZXBlbmRBdCA9IChkYXRhLCB2YWx1ZSkgPT4gW1xuICAgIC4uLmNvbnZlcnRUb0FycmF5UGF5bG9hZCh2YWx1ZSksXG4gICAgLi4uY29udmVydFRvQXJyYXlQYXlsb2FkKGRhdGEpLFxuXTtcblxuZnVuY3Rpb24gcmVtb3ZlQXRJbmRleGVzKGRhdGEsIGluZGV4ZXMpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgdGVtcCA9IFsuLi5kYXRhXTtcbiAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGV4ZXMpIHtcbiAgICAgICAgdGVtcC5zcGxpY2UoaW5kZXggLSBpLCAxKTtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gY29tcGFjdCh0ZW1wKS5sZW5ndGggPyB0ZW1wIDogW107XG59XG52YXIgcmVtb3ZlQXJyYXlBdCA9IChkYXRhLCBpbmRleCkgPT4gaXNVbmRlZmluZWQoaW5kZXgpXG4gICAgPyBbXVxuICAgIDogcmVtb3ZlQXRJbmRleGVzKGRhdGEsIGNvbnZlcnRUb0FycmF5UGF5bG9hZChpbmRleCkuc29ydCgoYSwgYikgPT4gYSAtIGIpKTtcblxudmFyIHN3YXBBcnJheUF0ID0gKGRhdGEsIGluZGV4QSwgaW5kZXhCKSA9PiB7XG4gICAgW2RhdGFbaW5kZXhBXSwgZGF0YVtpbmRleEJdXSA9IFtkYXRhW2luZGV4Ql0sIGRhdGFbaW5kZXhBXV07XG59O1xuXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgdXBkYXRlUGF0aCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IHVwZGF0ZVBhdGguc2xpY2UoMCwgLTEpLmxlbmd0aDtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBvYmplY3QgPSBpc1VuZGVmaW5lZChvYmplY3QpID8gaW5kZXgrKyA6IG9iamVjdFt1cGRhdGVQYXRoW2luZGV4KytdXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbmZ1bmN0aW9uIGlzRW1wdHlBcnJheShvYmopIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICFpc1VuZGVmaW5lZChvYmpba2V5XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgIGNvbnN0IHBhdGhzID0gQXJyYXkuaXNBcnJheShwYXRoKVxuICAgICAgICA/IHBhdGhcbiAgICAgICAgOiBpc0tleShwYXRoKVxuICAgICAgICAgICAgPyBbcGF0aF1cbiAgICAgICAgICAgIDogc3RyaW5nVG9QYXRoKHBhdGgpO1xuICAgIGNvbnN0IGNoaWxkT2JqZWN0ID0gcGF0aHMubGVuZ3RoID09PSAxID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIHBhdGhzKTtcbiAgICBjb25zdCBpbmRleCA9IHBhdGhzLmxlbmd0aCAtIDE7XG4gICAgY29uc3Qga2V5ID0gcGF0aHNbaW5kZXhdO1xuICAgIGlmIChjaGlsZE9iamVjdCkge1xuICAgICAgICBkZWxldGUgY2hpbGRPYmplY3Rba2V5XTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSAwICYmXG4gICAgICAgICgoaXNPYmplY3QoY2hpbGRPYmplY3QpICYmIGlzRW1wdHlPYmplY3QoY2hpbGRPYmplY3QpKSB8fFxuICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoY2hpbGRPYmplY3QpICYmIGlzRW1wdHlBcnJheShjaGlsZE9iamVjdCkpKSkge1xuICAgICAgICB1bnNldChvYmplY3QsIHBhdGhzLnNsaWNlKDAsIC0xKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG5cbnZhciB1cGRhdGVBdCA9IChmaWVsZFZhbHVlcywgaW5kZXgsIHZhbHVlKSA9PiB7XG4gICAgZmllbGRWYWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgcmV0dXJuIGZpZWxkVmFsdWVzO1xufTtcblxuLyoqXG4gKiBBIGN1c3RvbSBob29rIHRoYXQgZXhwb3NlcyBjb252ZW5pZW50IG1ldGhvZHMgdG8gcGVyZm9ybSBvcGVyYXRpb25zIHdpdGggYSBsaXN0IG9mIGR5bmFtaWMgaW5wdXRzIHRoYXQgbmVlZCB0byBiZSBhcHBlbmRlZCwgdXBkYXRlZCwgcmVtb3ZlZCBldGMuIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS11c2VmaWVsZGFycmF5LXNzdWduKSDigKIgW1ZpZGVvXShodHRwczovL3lvdXR1LmJlLzRNcmJmR1NGWTJBKVxuICpcbiAqIEByZW1hcmtzXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2VmaWVsZGFycmF5KSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tdXNlZmllbGRhcnJheS1zc3VnbilcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSB1c2VGaWVsZEFycmF5IHByb3BzXG4gKlxuICogQHJldHVybnMgbWV0aG9kcyAtIGZ1bmN0aW9ucyB0byBtYW5pcHVsYXRlIHdpdGggdGhlIEZpZWxkIEFycmF5cyAoZHluYW1pYyBpbnB1dHMpIHtAbGluayBVc2VGaWVsZEFycmF5UmV0dXJufVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgY29uc3QgeyByZWdpc3RlciwgY29udHJvbCwgaGFuZGxlU3VibWl0LCByZXNldCwgdHJpZ2dlciwgc2V0RXJyb3IgfSA9IHVzZUZvcm0oe1xuICogICAgIGRlZmF1bHRWYWx1ZXM6IHtcbiAqICAgICAgIHRlc3Q6IFtdXG4gKiAgICAgfVxuICogICB9KTtcbiAqICAgY29uc3QgeyBmaWVsZHMsIGFwcGVuZCB9ID0gdXNlRmllbGRBcnJheSh7XG4gKiAgICAgY29udHJvbCxcbiAqICAgICBuYW1lOiBcInRlc3RcIlxuICogICB9KTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGZvcm0gb25TdWJtaXQ9e2hhbmRsZVN1Ym1pdChkYXRhID0+IGNvbnNvbGUubG9nKGRhdGEpKX0+XG4gKiAgICAgICB7ZmllbGRzLm1hcCgoaXRlbSwgaW5kZXgpID0+IChcbiAqICAgICAgICAgIDxpbnB1dCBrZXk9e2l0ZW0uaWR9IHsuLi5yZWdpc3RlcihgdGVzdC4ke2luZGV4fS5maXJzdE5hbWVgKX0gIC8+XG4gKiAgICAgICApKX1cbiAqICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIG9uQ2xpY2s9eygpID0+IGFwcGVuZCh7IGZpcnN0TmFtZTogXCJiaWxsXCIgfSl9PlxuICogICAgICAgICBhcHBlbmRcbiAqICAgICAgIDwvYnV0dG9uPlxuICogICAgICAgPGlucHV0IHR5cGU9XCJzdWJtaXRcIiAvPlxuICogICAgIDwvZm9ybT5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VGaWVsZEFycmF5KHByb3BzKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IHVzZUZvcm1Db250ZXh0KCk7XG4gICAgY29uc3QgeyBjb250cm9sID0gbWV0aG9kcy5jb250cm9sLCBuYW1lLCBrZXlOYW1lID0gJ2lkJywgc2hvdWxkVW5yZWdpc3RlciwgfSA9IHByb3BzO1xuICAgIGNvbnN0IFtmaWVsZHMsIHNldEZpZWxkc10gPSBSZWFjdC51c2VTdGF0ZShjb250cm9sLl9nZXRGaWVsZEFycmF5KG5hbWUpKTtcbiAgICBjb25zdCBpZHMgPSBSZWFjdC51c2VSZWYoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKS5tYXAoZ2VuZXJhdGVJZCkpO1xuICAgIGNvbnN0IF9maWVsZElkcyA9IFJlYWN0LnVzZVJlZihmaWVsZHMpO1xuICAgIGNvbnN0IF9uYW1lID0gUmVhY3QudXNlUmVmKG5hbWUpO1xuICAgIGNvbnN0IF9hY3Rpb25lZCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgX25hbWUuY3VycmVudCA9IG5hbWU7XG4gICAgX2ZpZWxkSWRzLmN1cnJlbnQgPSBmaWVsZHM7XG4gICAgY29udHJvbC5fbmFtZXMuYXJyYXkuYWRkKG5hbWUpO1xuICAgIHByb3BzLnJ1bGVzICYmXG4gICAgICAgIGNvbnRyb2wucmVnaXN0ZXIobmFtZSwgcHJvcHMucnVsZXMpO1xuICAgIHVzZVN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6ICh7IHZhbHVlcywgbmFtZTogZmllbGRBcnJheU5hbWUsIH0pID0+IHtcbiAgICAgICAgICAgIGlmIChmaWVsZEFycmF5TmFtZSA9PT0gX25hbWUuY3VycmVudCB8fCAhZmllbGRBcnJheU5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGdldCh2YWx1ZXMsIF9uYW1lLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkVmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRGaWVsZHMoZmllbGRWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZHMuY3VycmVudCA9IGZpZWxkVmFsdWVzLm1hcChnZW5lcmF0ZUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN1YmplY3Q6IGNvbnRyb2wuX3N1YmplY3RzLmFycmF5LFxuICAgIH0pO1xuICAgIGNvbnN0IHVwZGF0ZVZhbHVlcyA9IFJlYWN0LnVzZUNhbGxiYWNrKCh1cGRhdGVkRmllbGRBcnJheVZhbHVlcykgPT4ge1xuICAgICAgICBfYWN0aW9uZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIGNvbnRyb2wuX3VwZGF0ZUZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgIH0sIFtjb250cm9sLCBuYW1lXSk7XG4gICAgY29uc3QgYXBwZW5kID0gKHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IGFwcGVuZFZhbHVlID0gY29udmVydFRvQXJyYXlQYXlsb2FkKGNsb25lT2JqZWN0KHZhbHVlKSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gYXBwZW5kQXQoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKSwgYXBwZW5kVmFsdWUpO1xuICAgICAgICBjb250cm9sLl9uYW1lcy5mb2N1cyA9IGdldEZvY3VzRmllbGROYW1lKG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLmxlbmd0aCAtIDEsIG9wdGlvbnMpO1xuICAgICAgICBpZHMuY3VycmVudCA9IGFwcGVuZEF0KGlkcy5jdXJyZW50LCBhcHBlbmRWYWx1ZS5tYXAoZ2VuZXJhdGVJZCkpO1xuICAgICAgICB1cGRhdGVWYWx1ZXModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBzZXRGaWVsZHModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBjb250cm9sLl91cGRhdGVGaWVsZEFycmF5KG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCBhcHBlbmRBdCwge1xuICAgICAgICAgICAgYXJnQTogZmlsbEVtcHR5QXJyYXkodmFsdWUpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHByZXBlbmQgPSAodmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgcHJlcGVuZFZhbHVlID0gY29udmVydFRvQXJyYXlQYXlsb2FkKGNsb25lT2JqZWN0KHZhbHVlKSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gcHJlcGVuZEF0KGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSksIHByZXBlbmRWYWx1ZSk7XG4gICAgICAgIGNvbnRyb2wuX25hbWVzLmZvY3VzID0gZ2V0Rm9jdXNGaWVsZE5hbWUobmFtZSwgMCwgb3B0aW9ucyk7XG4gICAgICAgIGlkcy5jdXJyZW50ID0gcHJlcGVuZEF0KGlkcy5jdXJyZW50LCBwcmVwZW5kVmFsdWUubWFwKGdlbmVyYXRlSWQpKTtcbiAgICAgICAgdXBkYXRlVmFsdWVzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgY29udHJvbC5fdXBkYXRlRmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgcHJlcGVuZEF0LCB7XG4gICAgICAgICAgICBhcmdBOiBmaWxsRW1wdHlBcnJheSh2YWx1ZSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlID0gKGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gcmVtb3ZlQXJyYXlBdChjb250cm9sLl9nZXRGaWVsZEFycmF5KG5hbWUpLCBpbmRleCk7XG4gICAgICAgIGlkcy5jdXJyZW50ID0gcmVtb3ZlQXJyYXlBdChpZHMuY3VycmVudCwgaW5kZXgpO1xuICAgICAgICB1cGRhdGVWYWx1ZXModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBzZXRGaWVsZHModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBjb250cm9sLl91cGRhdGVGaWVsZEFycmF5KG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCByZW1vdmVBcnJheUF0LCB7XG4gICAgICAgICAgICBhcmdBOiBpbmRleCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnQkMSA9IChpbmRleCwgdmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgaW5zZXJ0VmFsdWUgPSBjb252ZXJ0VG9BcnJheVBheWxvYWQoY2xvbmVPYmplY3QodmFsdWUpKTtcbiAgICAgICAgY29uc3QgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgPSBpbnNlcnQoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKSwgaW5kZXgsIGluc2VydFZhbHVlKTtcbiAgICAgICAgY29udHJvbC5fbmFtZXMuZm9jdXMgPSBnZXRGb2N1c0ZpZWxkTmFtZShuYW1lLCBpbmRleCwgb3B0aW9ucyk7XG4gICAgICAgIGlkcy5jdXJyZW50ID0gaW5zZXJ0KGlkcy5jdXJyZW50LCBpbmRleCwgaW5zZXJ0VmFsdWUubWFwKGdlbmVyYXRlSWQpKTtcbiAgICAgICAgdXBkYXRlVmFsdWVzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgY29udHJvbC5fdXBkYXRlRmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgaW5zZXJ0LCB7XG4gICAgICAgICAgICBhcmdBOiBpbmRleCxcbiAgICAgICAgICAgIGFyZ0I6IGZpbGxFbXB0eUFycmF5KHZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzd2FwID0gKGluZGV4QSwgaW5kZXhCKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKTtcbiAgICAgICAgc3dhcEFycmF5QXQodXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIGluZGV4QSwgaW5kZXhCKTtcbiAgICAgICAgc3dhcEFycmF5QXQoaWRzLmN1cnJlbnQsIGluZGV4QSwgaW5kZXhCKTtcbiAgICAgICAgdXBkYXRlVmFsdWVzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgY29udHJvbC5fdXBkYXRlRmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgc3dhcEFycmF5QXQsIHtcbiAgICAgICAgICAgIGFyZ0E6IGluZGV4QSxcbiAgICAgICAgICAgIGFyZ0I6IGluZGV4QixcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgIH07XG4gICAgY29uc3QgbW92ZSA9IChmcm9tLCB0bykgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSk7XG4gICAgICAgIG1vdmVBcnJheUF0KHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCBmcm9tLCB0byk7XG4gICAgICAgIG1vdmVBcnJheUF0KGlkcy5jdXJyZW50LCBmcm9tLCB0byk7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIHNldEZpZWxkcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIGNvbnRyb2wuX3VwZGF0ZUZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIG1vdmVBcnJheUF0LCB7XG4gICAgICAgICAgICBhcmdBOiBmcm9tLFxuICAgICAgICAgICAgYXJnQjogdG8sXG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZSA9IChpbmRleCwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlVmFsdWUgPSBjbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gdXBkYXRlQXQoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKSwgaW5kZXgsIHVwZGF0ZVZhbHVlKTtcbiAgICAgICAgaWRzLmN1cnJlbnQgPSBbLi4udXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXNdLm1hcCgoaXRlbSwgaSkgPT4gIWl0ZW0gfHwgaSA9PT0gaW5kZXggPyBnZW5lcmF0ZUlkKCkgOiBpZHMuY3VycmVudFtpXSk7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIHNldEZpZWxkcyhbLi4udXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXNdKTtcbiAgICAgICAgY29udHJvbC5fdXBkYXRlRmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgdXBkYXRlQXQsIHtcbiAgICAgICAgICAgIGFyZ0E6IGluZGV4LFxuICAgICAgICAgICAgYXJnQjogdXBkYXRlVmFsdWUsXG4gICAgICAgIH0sIHRydWUsIGZhbHNlKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlcGxhY2UgPSAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgPSBjb252ZXJ0VG9BcnJheVBheWxvYWQoY2xvbmVPYmplY3QodmFsdWUpKTtcbiAgICAgICAgaWRzLmN1cnJlbnQgPSB1cGRhdGVkRmllbGRBcnJheVZhbHVlcy5tYXAoZ2VuZXJhdGVJZCk7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyhbLi4udXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXNdKTtcbiAgICAgICAgc2V0RmllbGRzKFsuLi51cGRhdGVkRmllbGRBcnJheVZhbHVlc10pO1xuICAgICAgICBjb250cm9sLl91cGRhdGVGaWVsZEFycmF5KG5hbWUsIFsuLi51cGRhdGVkRmllbGRBcnJheVZhbHVlc10sIChkYXRhKSA9PiBkYXRhLCB7fSwgdHJ1ZSwgZmFsc2UpO1xuICAgIH07XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29udHJvbC5fc3RhdGUuYWN0aW9uID0gZmFsc2U7XG4gICAgICAgIGlzV2F0Y2hlZChuYW1lLCBjb250cm9sLl9uYW1lcykgJiZcbiAgICAgICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIC4uLmNvbnRyb2wuX2Zvcm1TdGF0ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoX2FjdGlvbmVkLmN1cnJlbnQgJiZcbiAgICAgICAgICAgICghZ2V0VmFsaWRhdGlvbk1vZGVzKGNvbnRyb2wuX29wdGlvbnMubW9kZSkuaXNPblN1Ym1pdCB8fFxuICAgICAgICAgICAgICAgIGNvbnRyb2wuX2Zvcm1TdGF0ZS5pc1N1Ym1pdHRlZCkpIHtcbiAgICAgICAgICAgIGlmIChjb250cm9sLl9vcHRpb25zLnJlc29sdmVyKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbC5fZXhlY3V0ZVNjaGVtYShbbmFtZV0pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGdldChyZXN1bHQuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdFcnJvciA9IGdldChjb250cm9sLl9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKCFlcnJvciAmJiBleGlzdGluZ0Vycm9yLnR5cGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChleGlzdGluZ0Vycm9yLnR5cGUgIT09IGVycm9yLnR5cGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nRXJyb3IubWVzc2FnZSAhPT0gZXJyb3IubWVzc2FnZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGVycm9yICYmIGVycm9yLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzZXQoY29udHJvbC5fZm9ybVN0YXRlLmVycm9ycywgbmFtZSwgZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bnNldChjb250cm9sLl9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yczogY29udHJvbC5fZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChjb250cm9sLl9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZCAmJlxuICAgICAgICAgICAgICAgICAgICBmaWVsZC5fZiAmJlxuICAgICAgICAgICAgICAgICAgICAhKGdldFZhbGlkYXRpb25Nb2Rlcyhjb250cm9sLl9vcHRpb25zLnJlVmFsaWRhdGVNb2RlKS5pc09uU3VibWl0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRWYWxpZGF0aW9uTW9kZXMoY29udHJvbC5fb3B0aW9ucy5tb2RlKS5pc09uU3VibWl0KSkge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUZpZWxkKGZpZWxkLCBjb250cm9sLl9mb3JtVmFsdWVzLCBjb250cm9sLl9vcHRpb25zLmNyaXRlcmlhTW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLmFsbCwgY29udHJvbC5fb3B0aW9ucy5zaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uLCB0cnVlKS50aGVuKChlcnJvcikgPT4gIWlzRW1wdHlPYmplY3QoZXJyb3IpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IHVwZGF0ZUZpZWxkQXJyYXlSb290RXJyb3IoY29udHJvbC5fZm9ybVN0YXRlLmVycm9ycywgZXJyb3IsIG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250cm9sLl9zdWJqZWN0cy52YWx1ZXMubmV4dCh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdmFsdWVzOiB7IC4uLmNvbnRyb2wuX2Zvcm1WYWx1ZXMgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRyb2wuX25hbWVzLmZvY3VzICYmXG4gICAgICAgICAgICBpdGVyYXRlRmllbGRzQnlBY3Rpb24oY29udHJvbC5fZmllbGRzLCAocmVmLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbC5fbmFtZXMuZm9jdXMgJiZcbiAgICAgICAgICAgICAgICAgICAga2V5LnN0YXJ0c1dpdGgoY29udHJvbC5fbmFtZXMuZm9jdXMpICYmXG4gICAgICAgICAgICAgICAgICAgIHJlZi5mb2N1cykge1xuICAgICAgICAgICAgICAgICAgICByZWYuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjb250cm9sLl9uYW1lcy5mb2N1cyA9ICcnO1xuICAgICAgICBjb250cm9sLl91cGRhdGVWYWxpZCgpO1xuICAgICAgICBfYWN0aW9uZWQuY3VycmVudCA9IGZhbHNlO1xuICAgIH0sIFtmaWVsZHMsIG5hbWUsIGNvbnRyb2xdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAhZ2V0KGNvbnRyb2wuX2Zvcm1WYWx1ZXMsIG5hbWUpICYmIGNvbnRyb2wuX3VwZGF0ZUZpZWxkQXJyYXkobmFtZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAoY29udHJvbC5fb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyIHx8IHNob3VsZFVucmVnaXN0ZXIpICYmXG4gICAgICAgICAgICAgICAgY29udHJvbC51bnJlZ2lzdGVyKG5hbWUpO1xuICAgICAgICB9O1xuICAgIH0sIFtuYW1lLCBjb250cm9sLCBrZXlOYW1lLCBzaG91bGRVbnJlZ2lzdGVyXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3dhcDogUmVhY3QudXNlQ2FsbGJhY2soc3dhcCwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgICAgICBtb3ZlOiBSZWFjdC51c2VDYWxsYmFjayhtb3ZlLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgICAgIHByZXBlbmQ6IFJlYWN0LnVzZUNhbGxiYWNrKHByZXBlbmQsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgYXBwZW5kOiBSZWFjdC51c2VDYWxsYmFjayhhcHBlbmQsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgcmVtb3ZlOiBSZWFjdC51c2VDYWxsYmFjayhyZW1vdmUsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgaW5zZXJ0OiBSZWFjdC51c2VDYWxsYmFjayhpbnNlcnQkMSwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgICAgICB1cGRhdGU6IFJlYWN0LnVzZUNhbGxiYWNrKHVwZGF0ZSwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgICAgICByZXBsYWNlOiBSZWFjdC51c2VDYWxsYmFjayhyZXBsYWNlLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgICAgIGZpZWxkczogUmVhY3QudXNlTWVtbygoKSA9PiBmaWVsZHMubWFwKChmaWVsZCwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICAuLi5maWVsZCxcbiAgICAgICAgICAgIFtrZXlOYW1lXTogaWRzLmN1cnJlbnRbaW5kZXhdIHx8IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgfSkpLCBbZmllbGRzLCBrZXlOYW1lXSksXG4gICAgfTtcbn1cblxudmFyIGNyZWF0ZVN1YmplY3QgPSAoKSA9PiB7XG4gICAgbGV0IF9vYnNlcnZlcnMgPSBbXTtcbiAgICBjb25zdCBuZXh0ID0gKHZhbHVlKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgb2JzZXJ2ZXIgb2YgX29ic2VydmVycykge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCAmJiBvYnNlcnZlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc3Vic2NyaWJlID0gKG9ic2VydmVyKSA9PiB7XG4gICAgICAgIF9vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIF9vYnNlcnZlcnMgPSBfb2JzZXJ2ZXJzLmZpbHRlcigobykgPT4gbyAhPT0gb2JzZXJ2ZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgICAgICBfb2JzZXJ2ZXJzID0gW107XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQgb2JzZXJ2ZXJzKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYnNlcnZlcnM7XG4gICAgICAgIH0sXG4gICAgICAgIG5leHQsXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgdW5zdWJzY3JpYmUsXG4gICAgfTtcbn07XG5cbnZhciBpc1ByaW1pdGl2ZSA9ICh2YWx1ZSkgPT4gaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpIHx8ICFpc09iamVjdFR5cGUodmFsdWUpO1xuXG5mdW5jdGlvbiBkZWVwRXF1YWwob2JqZWN0MSwgb2JqZWN0Mikge1xuICAgIGlmIChpc1ByaW1pdGl2ZShvYmplY3QxKSB8fCBpc1ByaW1pdGl2ZShvYmplY3QyKSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0MSA9PT0gb2JqZWN0MjtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZU9iamVjdChvYmplY3QxKSAmJiBpc0RhdGVPYmplY3Qob2JqZWN0MikpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDEuZ2V0VGltZSgpID09PSBvYmplY3QyLmdldFRpbWUoKTtcbiAgICB9XG4gICAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyhvYmplY3QxKTtcbiAgICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9iamVjdDIpO1xuICAgIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMxKSB7XG4gICAgICAgIGNvbnN0IHZhbDEgPSBvYmplY3QxW2tleV07XG4gICAgICAgIGlmICgha2V5czIuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgIT09ICdyZWYnKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwyID0gb2JqZWN0MltrZXldO1xuICAgICAgICAgICAgaWYgKChpc0RhdGVPYmplY3QodmFsMSkgJiYgaXNEYXRlT2JqZWN0KHZhbDIpKSB8fFxuICAgICAgICAgICAgICAgIChpc09iamVjdCh2YWwxKSAmJiBpc09iamVjdCh2YWwyKSkgfHxcbiAgICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheSh2YWwxKSAmJiBBcnJheS5pc0FycmF5KHZhbDIpKVxuICAgICAgICAgICAgICAgID8gIWRlZXBFcXVhbCh2YWwxLCB2YWwyKVxuICAgICAgICAgICAgICAgIDogdmFsMSAhPT0gdmFsMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIGlzTXVsdGlwbGVTZWxlY3QgPSAoZWxlbWVudCkgPT4gZWxlbWVudC50eXBlID09PSBgc2VsZWN0LW11bHRpcGxlYDtcblxudmFyIGlzUmFkaW9PckNoZWNrYm94ID0gKHJlZikgPT4gaXNSYWRpb0lucHV0KHJlZikgfHwgaXNDaGVja0JveElucHV0KHJlZik7XG5cbnZhciBsaXZlID0gKHJlZikgPT4gaXNIVE1MRWxlbWVudChyZWYpICYmIHJlZi5pc0Nvbm5lY3RlZDtcblxudmFyIG9iamVjdEhhc0Z1bmN0aW9uID0gKGRhdGEpID0+IHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGRhdGFba2V5XSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIG1hcmtGaWVsZHNEaXJ0eShkYXRhLCBmaWVsZHMgPSB7fSkge1xuICAgIGNvbnN0IGlzUGFyZW50Tm9kZUFycmF5ID0gQXJyYXkuaXNBcnJheShkYXRhKTtcbiAgICBpZiAoaXNPYmplY3QoZGF0YSkgfHwgaXNQYXJlbnROb2RlQXJyYXkpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVtrZXldKSB8fFxuICAgICAgICAgICAgICAgIChpc09iamVjdChkYXRhW2tleV0pICYmICFvYmplY3RIYXNGdW5jdGlvbihkYXRhW2tleV0pKSkge1xuICAgICAgICAgICAgICAgIGZpZWxkc1trZXldID0gQXJyYXkuaXNBcnJheShkYXRhW2tleV0pID8gW10gOiB7fTtcbiAgICAgICAgICAgICAgICBtYXJrRmllbGRzRGlydHkoZGF0YVtrZXldLCBmaWVsZHNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNOdWxsT3JVbmRlZmluZWQoZGF0YVtrZXldKSkge1xuICAgICAgICAgICAgICAgIGZpZWxkc1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmllbGRzO1xufVxuZnVuY3Rpb24gZ2V0RGlydHlGaWVsZHNGcm9tRGVmYXVsdFZhbHVlcyhkYXRhLCBmb3JtVmFsdWVzLCBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXMpIHtcbiAgICBjb25zdCBpc1BhcmVudE5vZGVBcnJheSA9IEFycmF5LmlzQXJyYXkoZGF0YSk7XG4gICAgaWYgKGlzT2JqZWN0KGRhdGEpIHx8IGlzUGFyZW50Tm9kZUFycmF5KSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFba2V5XSkgfHxcbiAgICAgICAgICAgICAgICAoaXNPYmplY3QoZGF0YVtrZXldKSAmJiAhb2JqZWN0SGFzRnVuY3Rpb24oZGF0YVtrZXldKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoZm9ybVZhbHVlcykgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNQcmltaXRpdmUoZGlydHlGaWVsZHNGcm9tVmFsdWVzW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpcnR5RmllbGRzRnJvbVZhbHVlc1trZXldID0gQXJyYXkuaXNBcnJheShkYXRhW2tleV0pXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG1hcmtGaWVsZHNEaXJ0eShkYXRhW2tleV0sIFtdKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7IC4uLm1hcmtGaWVsZHNEaXJ0eShkYXRhW2tleV0pIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXREaXJ0eUZpZWxkc0Zyb21EZWZhdWx0VmFsdWVzKGRhdGFba2V5XSwgaXNOdWxsT3JVbmRlZmluZWQoZm9ybVZhbHVlcykgPyB7fSA6IGZvcm1WYWx1ZXNba2V5XSwgZGlydHlGaWVsZHNGcm9tVmFsdWVzW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpcnR5RmllbGRzRnJvbVZhbHVlc1trZXldID0gIWRlZXBFcXVhbChkYXRhW2tleV0sIGZvcm1WYWx1ZXNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpcnR5RmllbGRzRnJvbVZhbHVlcztcbn1cbnZhciBnZXREaXJ0eUZpZWxkcyA9IChkZWZhdWx0VmFsdWVzLCBmb3JtVmFsdWVzKSA9PiBnZXREaXJ0eUZpZWxkc0Zyb21EZWZhdWx0VmFsdWVzKGRlZmF1bHRWYWx1ZXMsIGZvcm1WYWx1ZXMsIG1hcmtGaWVsZHNEaXJ0eShmb3JtVmFsdWVzKSk7XG5cbnZhciBnZXRGaWVsZFZhbHVlQXMgPSAodmFsdWUsIHsgdmFsdWVBc051bWJlciwgdmFsdWVBc0RhdGUsIHNldFZhbHVlQXMgfSkgPT4gaXNVbmRlZmluZWQodmFsdWUpXG4gICAgPyB2YWx1ZVxuICAgIDogdmFsdWVBc051bWJlclxuICAgICAgICA/IHZhbHVlID09PSAnJ1xuICAgICAgICAgICAgPyBOYU5cbiAgICAgICAgICAgIDogdmFsdWVcbiAgICAgICAgICAgICAgICA/ICt2YWx1ZVxuICAgICAgICAgICAgICAgIDogdmFsdWVcbiAgICAgICAgOiB2YWx1ZUFzRGF0ZSAmJiBpc1N0cmluZyh2YWx1ZSlcbiAgICAgICAgICAgID8gbmV3IERhdGUodmFsdWUpXG4gICAgICAgICAgICA6IHNldFZhbHVlQXNcbiAgICAgICAgICAgICAgICA/IHNldFZhbHVlQXModmFsdWUpXG4gICAgICAgICAgICAgICAgOiB2YWx1ZTtcblxuZnVuY3Rpb24gZ2V0RmllbGRWYWx1ZShfZikge1xuICAgIGNvbnN0IHJlZiA9IF9mLnJlZjtcbiAgICBpZiAoX2YucmVmcyA/IF9mLnJlZnMuZXZlcnkoKHJlZikgPT4gcmVmLmRpc2FibGVkKSA6IHJlZi5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0ZpbGVJbnB1dChyZWYpKSB7XG4gICAgICAgIHJldHVybiByZWYuZmlsZXM7XG4gICAgfVxuICAgIGlmIChpc1JhZGlvSW5wdXQocmVmKSkge1xuICAgICAgICByZXR1cm4gZ2V0UmFkaW9WYWx1ZShfZi5yZWZzKS52YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzTXVsdGlwbGVTZWxlY3QocmVmKSkge1xuICAgICAgICByZXR1cm4gWy4uLnJlZi5zZWxlY3RlZE9wdGlvbnNdLm1hcCgoeyB2YWx1ZSB9KSA9PiB2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChpc0NoZWNrQm94SW5wdXQocmVmKSkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hlY2tib3hWYWx1ZShfZi5yZWZzKS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEZpZWxkVmFsdWVBcyhpc1VuZGVmaW5lZChyZWYudmFsdWUpID8gX2YucmVmLnZhbHVlIDogcmVmLnZhbHVlLCBfZik7XG59XG5cbnZhciBnZXRSZXNvbHZlck9wdGlvbnMgPSAoZmllbGRzTmFtZXMsIF9maWVsZHMsIGNyaXRlcmlhTW9kZSwgc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbikgPT4ge1xuICAgIGNvbnN0IGZpZWxkcyA9IHt9O1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBmaWVsZHNOYW1lcykge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgZmllbGQgJiYgc2V0KGZpZWxkcywgbmFtZSwgZmllbGQuX2YpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjcml0ZXJpYU1vZGUsXG4gICAgICAgIG5hbWVzOiBbLi4uZmllbGRzTmFtZXNdLFxuICAgICAgICBmaWVsZHMsXG4gICAgICAgIHNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24sXG4gICAgfTtcbn07XG5cbnZhciBnZXRSdWxlVmFsdWUgPSAocnVsZSkgPT4gaXNVbmRlZmluZWQocnVsZSlcbiAgICA/IHJ1bGVcbiAgICA6IGlzUmVnZXgocnVsZSlcbiAgICAgICAgPyBydWxlLnNvdXJjZVxuICAgICAgICA6IGlzT2JqZWN0KHJ1bGUpXG4gICAgICAgICAgICA/IGlzUmVnZXgocnVsZS52YWx1ZSlcbiAgICAgICAgICAgICAgICA/IHJ1bGUudmFsdWUuc291cmNlXG4gICAgICAgICAgICAgICAgOiBydWxlLnZhbHVlXG4gICAgICAgICAgICA6IHJ1bGU7XG5cbnZhciBoYXNWYWxpZGF0aW9uID0gKG9wdGlvbnMpID0+IG9wdGlvbnMubW91bnQgJiZcbiAgICAob3B0aW9ucy5yZXF1aXJlZCB8fFxuICAgICAgICBvcHRpb25zLm1pbiB8fFxuICAgICAgICBvcHRpb25zLm1heCB8fFxuICAgICAgICBvcHRpb25zLm1heExlbmd0aCB8fFxuICAgICAgICBvcHRpb25zLm1pbkxlbmd0aCB8fFxuICAgICAgICBvcHRpb25zLnBhdHRlcm4gfHxcbiAgICAgICAgb3B0aW9ucy52YWxpZGF0ZSk7XG5cbmZ1bmN0aW9uIHNjaGVtYUVycm9yTG9va3VwKGVycm9ycywgX2ZpZWxkcywgbmFtZSkge1xuICAgIGNvbnN0IGVycm9yID0gZ2V0KGVycm9ycywgbmFtZSk7XG4gICAgaWYgKGVycm9yIHx8IGlzS2V5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG5hbWVzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgIHdoaWxlIChuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZmllbGROYW1lID0gbmFtZXMuam9pbignLicpO1xuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICBjb25zdCBmb3VuZEVycm9yID0gZ2V0KGVycm9ycywgZmllbGROYW1lKTtcbiAgICAgICAgaWYgKGZpZWxkICYmICFBcnJheS5pc0FycmF5KGZpZWxkKSAmJiBuYW1lICE9PSBmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWUgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmRFcnJvciAmJiBmb3VuZEVycm9yLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogZmllbGROYW1lLFxuICAgICAgICAgICAgICAgIGVycm9yOiBmb3VuZEVycm9yLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lcy5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZSxcbiAgICB9O1xufVxuXG52YXIgc2tpcFZhbGlkYXRpb24gPSAoaXNCbHVyRXZlbnQsIGlzVG91Y2hlZCwgaXNTdWJtaXR0ZWQsIHJlVmFsaWRhdGVNb2RlLCBtb2RlKSA9PiB7XG4gICAgaWYgKG1vZGUuaXNPbkFsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc1N1Ym1pdHRlZCAmJiBtb2RlLmlzT25Ub3VjaCkge1xuICAgICAgICByZXR1cm4gIShpc1RvdWNoZWQgfHwgaXNCbHVyRXZlbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1N1Ym1pdHRlZCA/IHJlVmFsaWRhdGVNb2RlLmlzT25CbHVyIDogbW9kZS5pc09uQmx1cikge1xuICAgICAgICByZXR1cm4gIWlzQmx1ckV2ZW50O1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1N1Ym1pdHRlZCA/IHJlVmFsaWRhdGVNb2RlLmlzT25DaGFuZ2UgOiBtb2RlLmlzT25DaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGlzQmx1ckV2ZW50O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciB1bnNldEVtcHR5QXJyYXkgPSAocmVmLCBuYW1lKSA9PiAhY29tcGFjdChnZXQocmVmLCBuYW1lKSkubGVuZ3RoICYmIHVuc2V0KHJlZiwgbmFtZSk7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG1vZGU6IFZBTElEQVRJT05fTU9ERS5vblN1Ym1pdCxcbiAgICByZVZhbGlkYXRlTW9kZTogVkFMSURBVElPTl9NT0RFLm9uQ2hhbmdlLFxuICAgIHNob3VsZEZvY3VzRXJyb3I6IHRydWUsXG59O1xuZnVuY3Rpb24gY3JlYXRlRm9ybUNvbnRyb2wocHJvcHMgPSB7fSwgZmx1c2hSb290UmVuZGVyKSB7XG4gICAgbGV0IF9vcHRpb25zID0ge1xuICAgICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgfTtcbiAgICBsZXQgX2Zvcm1TdGF0ZSA9IHtcbiAgICAgICAgc3VibWl0Q291bnQ6IDAsXG4gICAgICAgIGlzRGlydHk6IGZhbHNlLFxuICAgICAgICBpc0xvYWRpbmc6IGlzRnVuY3Rpb24oX29wdGlvbnMuZGVmYXVsdFZhbHVlcyksXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXG4gICAgICAgIGlzU3VibWl0dGVkOiBmYWxzZSxcbiAgICAgICAgaXNTdWJtaXR0aW5nOiBmYWxzZSxcbiAgICAgICAgaXNTdWJtaXRTdWNjZXNzZnVsOiBmYWxzZSxcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIHRvdWNoZWRGaWVsZHM6IHt9LFxuICAgICAgICBkaXJ0eUZpZWxkczoge30sXG4gICAgICAgIGVycm9yczogX29wdGlvbnMuZXJyb3JzIHx8IHt9LFxuICAgICAgICBkaXNhYmxlZDogX29wdGlvbnMuZGlzYWJsZWQgfHwgZmFsc2UsXG4gICAgfTtcbiAgICBsZXQgX2ZpZWxkcyA9IHt9O1xuICAgIGxldCBfZGVmYXVsdFZhbHVlcyA9IGlzT2JqZWN0KF9vcHRpb25zLnZhbHVlcykgfHwgaXNPYmplY3QoX29wdGlvbnMuZGVmYXVsdFZhbHVlcylcbiAgICAgICAgPyBjbG9uZU9iamVjdChfb3B0aW9ucy52YWx1ZXMgfHwgX29wdGlvbnMuZGVmYXVsdFZhbHVlcykgfHwge31cbiAgICAgICAgOiB7fTtcbiAgICBsZXQgX2Zvcm1WYWx1ZXMgPSBfb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyXG4gICAgICAgID8ge31cbiAgICAgICAgOiBjbG9uZU9iamVjdChfZGVmYXVsdFZhbHVlcyk7XG4gICAgbGV0IF9zdGF0ZSA9IHtcbiAgICAgICAgYWN0aW9uOiBmYWxzZSxcbiAgICAgICAgbW91bnQ6IGZhbHNlLFxuICAgICAgICB3YXRjaDogZmFsc2UsXG4gICAgfTtcbiAgICBsZXQgX25hbWVzID0ge1xuICAgICAgICBtb3VudDogbmV3IFNldCgpLFxuICAgICAgICB1bk1vdW50OiBuZXcgU2V0KCksXG4gICAgICAgIGFycmF5OiBuZXcgU2V0KCksXG4gICAgICAgIHdhdGNoOiBuZXcgU2V0KCksXG4gICAgfTtcbiAgICBsZXQgZGVsYXlFcnJvckNhbGxiYWNrO1xuICAgIGxldCB0aW1lciA9IDA7XG4gICAgY29uc3QgX3Byb3h5Rm9ybVN0YXRlID0ge1xuICAgICAgICBpc0RpcnR5OiBmYWxzZSxcbiAgICAgICAgZGlydHlGaWVsZHM6IGZhbHNlLFxuICAgICAgICB0b3VjaGVkRmllbGRzOiBmYWxzZSxcbiAgICAgICAgaXNWYWxpZGF0aW5nOiBmYWxzZSxcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIGVycm9yczogZmFsc2UsXG4gICAgfTtcbiAgICBjb25zdCBfc3ViamVjdHMgPSB7XG4gICAgICAgIHZhbHVlczogY3JlYXRlU3ViamVjdCgpLFxuICAgICAgICBhcnJheTogY3JlYXRlU3ViamVjdCgpLFxuICAgICAgICBzdGF0ZTogY3JlYXRlU3ViamVjdCgpLFxuICAgIH07XG4gICAgY29uc3QgdmFsaWRhdGlvbk1vZGVCZWZvcmVTdWJtaXQgPSBnZXRWYWxpZGF0aW9uTW9kZXMoX29wdGlvbnMubW9kZSk7XG4gICAgY29uc3QgdmFsaWRhdGlvbk1vZGVBZnRlclN1Ym1pdCA9IGdldFZhbGlkYXRpb25Nb2Rlcyhfb3B0aW9ucy5yZVZhbGlkYXRlTW9kZSk7XG4gICAgY29uc3Qgc2hvdWxkRGlzcGxheUFsbEFzc29jaWF0ZWRFcnJvcnMgPSBfb3B0aW9ucy5jcml0ZXJpYU1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5hbGw7XG4gICAgY29uc3QgZGVib3VuY2UgPSAoY2FsbGJhY2spID0+ICh3YWl0KSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChjYWxsYmFjaywgd2FpdCk7XG4gICAgfTtcbiAgICBjb25zdCBfdXBkYXRlVmFsaWQgPSBhc3luYyAoc2hvdWxkVXBkYXRlVmFsaWQpID0+IHtcbiAgICAgICAgaWYgKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkIHx8IHNob3VsZFVwZGF0ZVZhbGlkKSB7XG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gX29wdGlvbnMucmVzb2x2ZXJcbiAgICAgICAgICAgICAgICA/IGlzRW1wdHlPYmplY3QoKGF3YWl0IF9leGVjdXRlU2NoZW1hKCkpLmVycm9ycylcbiAgICAgICAgICAgICAgICA6IGF3YWl0IGV4ZWN1dGVCdWlsdEluVmFsaWRhdGlvbihfZmllbGRzLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkICE9PSBfZm9ybVN0YXRlLmlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgICAgIGlzVmFsaWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IF91cGRhdGVJc1ZhbGlkYXRpbmcgPSAodmFsdWUpID0+IF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkYXRpbmcgJiZcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiB2YWx1ZSxcbiAgICAgICAgfSk7XG4gICAgY29uc3QgX3VwZGF0ZUZpZWxkQXJyYXkgPSAobmFtZSwgdmFsdWVzID0gW10sIG1ldGhvZCwgYXJncywgc2hvdWxkU2V0VmFsdWVzID0gdHJ1ZSwgc2hvdWxkVXBkYXRlRmllbGRzQW5kU3RhdGUgPSB0cnVlKSA9PiB7XG4gICAgICAgIGlmIChhcmdzICYmIG1ldGhvZCkge1xuICAgICAgICAgICAgX3N0YXRlLmFjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlRmllbGRzQW5kU3RhdGUgJiYgQXJyYXkuaXNBcnJheShnZXQoX2ZpZWxkcywgbmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRWYWx1ZXMgPSBtZXRob2QoZ2V0KF9maWVsZHMsIG5hbWUpLCBhcmdzLmFyZ0EsIGFyZ3MuYXJnQik7XG4gICAgICAgICAgICAgICAgc2hvdWxkU2V0VmFsdWVzICYmIHNldChfZmllbGRzLCBuYW1lLCBmaWVsZFZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlRmllbGRzQW5kU3RhdGUgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KGdldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gbWV0aG9kKGdldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSksIGFyZ3MuYXJnQSwgYXJncy5hcmdCKTtcbiAgICAgICAgICAgICAgICBzaG91bGRTZXRWYWx1ZXMgJiYgc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lLCBlcnJvcnMpO1xuICAgICAgICAgICAgICAgIHVuc2V0RW1wdHlBcnJheShfZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3Byb3h5Rm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMgJiZcbiAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVGaWVsZHNBbmRTdGF0ZSAmJlxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZ2V0KF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkcywgbmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG91Y2hlZEZpZWxkcyA9IG1ldGhvZChnZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKSwgYXJncy5hcmdBLCBhcmdzLmFyZ0IpO1xuICAgICAgICAgICAgICAgIHNob3VsZFNldFZhbHVlcyAmJiBzZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lLCB0b3VjaGVkRmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfcHJveHlGb3JtU3RhdGUuZGlydHlGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBfZm9ybVN0YXRlLmRpcnR5RmllbGRzID0gZ2V0RGlydHlGaWVsZHMoX2RlZmF1bHRWYWx1ZXMsIF9mb3JtVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGlzRGlydHk6IF9nZXREaXJ0eShuYW1lLCB2YWx1ZXMpLFxuICAgICAgICAgICAgICAgIGRpcnR5RmllbGRzOiBfZm9ybVN0YXRlLmRpcnR5RmllbGRzLFxuICAgICAgICAgICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgICAgICAgICAgaXNWYWxpZDogX2Zvcm1TdGF0ZS5pc1ZhbGlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZUVycm9ycyA9IChuYW1lLCBlcnJvcikgPT4ge1xuICAgICAgICBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9yKTtcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBfc2V0RXJyb3JzID0gKGVycm9ycykgPT4ge1xuICAgICAgICBfZm9ybVN0YXRlLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZVZhbGlkQW5kVmFsdWUgPSAobmFtZSwgc2hvdWxkU2tpcFNldFZhbHVlQXMsIHZhbHVlLCByZWYpID0+IHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gZ2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBpc1VuZGVmaW5lZCh2YWx1ZSkgPyBnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUpIDogdmFsdWUpO1xuICAgICAgICAgICAgaXNVbmRlZmluZWQoZGVmYXVsdFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIChyZWYgJiYgcmVmLmRlZmF1bHRDaGVja2VkKSB8fFxuICAgICAgICAgICAgICAgIHNob3VsZFNraXBTZXRWYWx1ZUFzXG4gICAgICAgICAgICAgICAgPyBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIHNob3VsZFNraXBTZXRWYWx1ZUFzID8gZGVmYXVsdFZhbHVlIDogZ2V0RmllbGRWYWx1ZShmaWVsZC5fZikpXG4gICAgICAgICAgICAgICAgOiBzZXRGaWVsZFZhbHVlKG5hbWUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICBfc3RhdGUubW91bnQgJiYgX3VwZGF0ZVZhbGlkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZVRvdWNoQW5kRGlydHkgPSAobmFtZSwgZmllbGRWYWx1ZSwgaXNCbHVyRXZlbnQsIHNob3VsZERpcnR5LCBzaG91bGRSZW5kZXIpID0+IHtcbiAgICAgICAgbGV0IHNob3VsZFVwZGF0ZUZpZWxkID0gZmFsc2U7XG4gICAgICAgIGxldCBpc1ByZXZpb3VzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZGlzYWJsZWRGaWVsZCA9ICEhKGdldChfZmllbGRzLCBuYW1lKSAmJiBnZXQoX2ZpZWxkcywgbmFtZSkuX2YuZGlzYWJsZWQpO1xuICAgICAgICBpZiAoIWlzQmx1ckV2ZW50IHx8IHNob3VsZERpcnR5KSB7XG4gICAgICAgICAgICBpZiAoX3Byb3h5Rm9ybVN0YXRlLmlzRGlydHkpIHtcbiAgICAgICAgICAgICAgICBpc1ByZXZpb3VzRGlydHkgPSBfZm9ybVN0YXRlLmlzRGlydHk7XG4gICAgICAgICAgICAgICAgX2Zvcm1TdGF0ZS5pc0RpcnR5ID0gb3V0cHV0LmlzRGlydHkgPSBfZ2V0RGlydHkoKTtcbiAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVGaWVsZCA9IGlzUHJldmlvdXNEaXJ0eSAhPT0gb3V0cHV0LmlzRGlydHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc0N1cnJlbnRGaWVsZFByaXN0aW5lID0gZGlzYWJsZWRGaWVsZCB8fCBkZWVwRXF1YWwoZ2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lKSwgZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBpc1ByZXZpb3VzRGlydHkgPSAhISghZGlzYWJsZWRGaWVsZCAmJiBnZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSkpO1xuICAgICAgICAgICAgaXNDdXJyZW50RmllbGRQcmlzdGluZSB8fCBkaXNhYmxlZEZpZWxkXG4gICAgICAgICAgICAgICAgPyB1bnNldChfZm9ybVN0YXRlLmRpcnR5RmllbGRzLCBuYW1lKVxuICAgICAgICAgICAgICAgIDogc2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIG5hbWUsIHRydWUpO1xuICAgICAgICAgICAgb3V0cHV0LmRpcnR5RmllbGRzID0gX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcztcbiAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkID1cbiAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVGaWVsZCB8fFxuICAgICAgICAgICAgICAgICAgICAoX3Byb3h5Rm9ybVN0YXRlLmRpcnR5RmllbGRzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZpb3VzRGlydHkgIT09ICFpc0N1cnJlbnRGaWVsZFByaXN0aW5lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCbHVyRXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzUHJldmlvdXNGaWVsZFRvdWNoZWQgPSBnZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgIGlmICghaXNQcmV2aW91c0ZpZWxkVG91Y2hlZCkge1xuICAgICAgICAgICAgICAgIHNldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUsIGlzQmx1ckV2ZW50KTtcbiAgICAgICAgICAgICAgICBvdXRwdXQudG91Y2hlZEZpZWxkcyA9IF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkcztcbiAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVGaWVsZCA9XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoX3Byb3h5Rm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZpb3VzRmllbGRUb3VjaGVkICE9PSBpc0JsdXJFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2hvdWxkVXBkYXRlRmllbGQgJiYgc2hvdWxkUmVuZGVyICYmIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KG91dHB1dCk7XG4gICAgICAgIHJldHVybiBzaG91bGRVcGRhdGVGaWVsZCA/IG91dHB1dCA6IHt9O1xuICAgIH07XG4gICAgY29uc3Qgc2hvdWxkUmVuZGVyQnlFcnJvciA9IChuYW1lLCBpc1ZhbGlkLCBlcnJvciwgZmllbGRTdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBwcmV2aW91c0ZpZWxkRXJyb3IgPSBnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpO1xuICAgICAgICBjb25zdCBzaG91bGRVcGRhdGVWYWxpZCA9IF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkICYmXG4gICAgICAgICAgICBpc0Jvb2xlYW4oaXNWYWxpZCkgJiZcbiAgICAgICAgICAgIF9mb3JtU3RhdGUuaXNWYWxpZCAhPT0gaXNWYWxpZDtcbiAgICAgICAgaWYgKHByb3BzLmRlbGF5RXJyb3IgJiYgZXJyb3IpIHtcbiAgICAgICAgICAgIGRlbGF5RXJyb3JDYWxsYmFjayA9IGRlYm91bmNlKCgpID0+IHVwZGF0ZUVycm9ycyhuYW1lLCBlcnJvcikpO1xuICAgICAgICAgICAgZGVsYXlFcnJvckNhbGxiYWNrKHByb3BzLmRlbGF5RXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIGRlbGF5RXJyb3JDYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgID8gc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lLCBlcnJvcilcbiAgICAgICAgICAgICAgICA6IHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGVycm9yID8gIWRlZXBFcXVhbChwcmV2aW91c0ZpZWxkRXJyb3IsIGVycm9yKSA6IHByZXZpb3VzRmllbGRFcnJvcikgfHxcbiAgICAgICAgICAgICFpc0VtcHR5T2JqZWN0KGZpZWxkU3RhdGUpIHx8XG4gICAgICAgICAgICBzaG91bGRVcGRhdGVWYWxpZCkge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZEZvcm1TdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5maWVsZFN0YXRlLFxuICAgICAgICAgICAgICAgIC4uLihzaG91bGRVcGRhdGVWYWxpZCAmJiBpc0Jvb2xlYW4oaXNWYWxpZCkgPyB7IGlzVmFsaWQgfSA6IHt9KSxcbiAgICAgICAgICAgICAgICBlcnJvcnM6IF9mb3JtU3RhdGUuZXJyb3JzLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX2Zvcm1TdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5fZm9ybVN0YXRlLFxuICAgICAgICAgICAgICAgIC4uLnVwZGF0ZWRGb3JtU3RhdGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQodXBkYXRlZEZvcm1TdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgX3VwZGF0ZUlzVmFsaWRhdGluZyhmYWxzZSk7XG4gICAgfTtcbiAgICBjb25zdCBfZXhlY3V0ZVNjaGVtYSA9IGFzeW5jIChuYW1lKSA9PiBfb3B0aW9ucy5yZXNvbHZlcihfZm9ybVZhbHVlcywgX29wdGlvbnMuY29udGV4dCwgZ2V0UmVzb2x2ZXJPcHRpb25zKG5hbWUgfHwgX25hbWVzLm1vdW50LCBfZmllbGRzLCBfb3B0aW9ucy5jcml0ZXJpYU1vZGUsIF9vcHRpb25zLnNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24pKTtcbiAgICBjb25zdCBleGVjdXRlU2NoZW1hQW5kVXBkYXRlU3RhdGUgPSBhc3luYyAobmFtZXMpID0+IHtcbiAgICAgICAgY29uc3QgeyBlcnJvcnMgfSA9IGF3YWl0IF9leGVjdXRlU2NoZW1hKG5hbWVzKTtcbiAgICAgICAgaWYgKG5hbWVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbmFtZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGdldChlcnJvcnMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICAgID8gc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lLCBlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgOiB1bnNldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfZm9ybVN0YXRlLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH07XG4gICAgY29uc3QgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uID0gYXN5bmMgKGZpZWxkcywgc2hvdWxkT25seUNoZWNrVmFsaWQsIGNvbnRleHQgPSB7XG4gICAgICAgIHZhbGlkOiB0cnVlLFxuICAgIH0pID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGZpZWxkcykge1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBmaWVsZHNbbmFtZV07XG4gICAgICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IF9mLCAuLi5maWVsZFZhbHVlIH0gPSBmaWVsZDtcbiAgICAgICAgICAgICAgICBpZiAoX2YpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNGaWVsZEFycmF5Um9vdCA9IF9uYW1lcy5hcnJheS5oYXMoX2YubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkRXJyb3IgPSBhd2FpdCB2YWxpZGF0ZUZpZWxkKGZpZWxkLCBfZm9ybVZhbHVlcywgc2hvdWxkRGlzcGxheUFsbEFzc29jaWF0ZWRFcnJvcnMsIF9vcHRpb25zLnNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24gJiYgIXNob3VsZE9ubHlDaGVja1ZhbGlkLCBpc0ZpZWxkQXJyYXlSb290KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkRXJyb3JbX2YubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRPbmx5Q2hlY2tWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICFzaG91bGRPbmx5Q2hlY2tWYWxpZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGdldChmaWVsZEVycm9yLCBfZi5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gaXNGaWVsZEFycmF5Um9vdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHVwZGF0ZUZpZWxkQXJyYXlSb290RXJyb3IoX2Zvcm1TdGF0ZS5lcnJvcnMsIGZpZWxkRXJyb3IsIF9mLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBfZi5uYW1lLCBmaWVsZEVycm9yW19mLm5hbWVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIF9mLm5hbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmllbGRWYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICAoYXdhaXQgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uKGZpZWxkVmFsdWUsIHNob3VsZE9ubHlDaGVja1ZhbGlkLCBjb250ZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRleHQudmFsaWQ7XG4gICAgfTtcbiAgICBjb25zdCBfcmVtb3ZlVW5tb3VudGVkID0gKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgX25hbWVzLnVuTW91bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgZmllbGQgJiZcbiAgICAgICAgICAgICAgICAoZmllbGQuX2YucmVmc1xuICAgICAgICAgICAgICAgICAgICA/IGZpZWxkLl9mLnJlZnMuZXZlcnkoKHJlZikgPT4gIWxpdmUocmVmKSlcbiAgICAgICAgICAgICAgICAgICAgOiAhbGl2ZShmaWVsZC5fZi5yZWYpKSAmJlxuICAgICAgICAgICAgICAgIHVucmVnaXN0ZXIobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgX25hbWVzLnVuTW91bnQgPSBuZXcgU2V0KCk7XG4gICAgfTtcbiAgICBjb25zdCBfZ2V0RGlydHkgPSAobmFtZSwgZGF0YSkgPT4gKG5hbWUgJiYgZGF0YSAmJiBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIGRhdGEpLFxuICAgICAgICAhZGVlcEVxdWFsKGdldFZhbHVlcygpLCBfZGVmYXVsdFZhbHVlcykpO1xuICAgIGNvbnN0IF9nZXRXYXRjaCA9IChuYW1lcywgZGVmYXVsdFZhbHVlLCBpc0dsb2JhbCkgPT4gZ2VuZXJhdGVXYXRjaE91dHB1dChuYW1lcywgX25hbWVzLCB7XG4gICAgICAgIC4uLihfc3RhdGUubW91bnRcbiAgICAgICAgICAgID8gX2Zvcm1WYWx1ZXNcbiAgICAgICAgICAgIDogaXNVbmRlZmluZWQoZGVmYXVsdFZhbHVlKVxuICAgICAgICAgICAgICAgID8gX2RlZmF1bHRWYWx1ZXNcbiAgICAgICAgICAgICAgICA6IGlzU3RyaW5nKG5hbWVzKVxuICAgICAgICAgICAgICAgICAgICA/IHsgW25hbWVzXTogZGVmYXVsdFZhbHVlIH1cbiAgICAgICAgICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWUpLFxuICAgIH0sIGlzR2xvYmFsLCBkZWZhdWx0VmFsdWUpO1xuICAgIGNvbnN0IF9nZXRGaWVsZEFycmF5ID0gKG5hbWUpID0+IGNvbXBhY3QoZ2V0KF9zdGF0ZS5tb3VudCA/IF9mb3JtVmFsdWVzIDogX2RlZmF1bHRWYWx1ZXMsIG5hbWUsIHByb3BzLnNob3VsZFVucmVnaXN0ZXIgPyBnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUsIFtdKSA6IFtdKSk7XG4gICAgY29uc3Qgc2V0RmllbGRWYWx1ZSA9IChuYW1lLCB2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICBsZXQgZmllbGRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkUmVmZXJlbmNlID0gZmllbGQuX2Y7XG4gICAgICAgICAgICBpZiAoZmllbGRSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAhZmllbGRSZWZlcmVuY2UuZGlzYWJsZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgc2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBnZXRGaWVsZFZhbHVlQXModmFsdWUsIGZpZWxkUmVmZXJlbmNlKSk7XG4gICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgIGlzSFRNTEVsZW1lbnQoZmllbGRSZWZlcmVuY2UucmVmKSAmJiBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGlzTXVsdGlwbGVTZWxlY3QoZmllbGRSZWZlcmVuY2UucmVmKSkge1xuICAgICAgICAgICAgICAgICAgICBbLi4uZmllbGRSZWZlcmVuY2UucmVmLm9wdGlvbnNdLmZvckVhY2goKG9wdGlvblJlZikgPT4gKG9wdGlvblJlZi5zZWxlY3RlZCA9IGZpZWxkVmFsdWUuaW5jbHVkZXMob3B0aW9uUmVmLnZhbHVlKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZFJlZmVyZW5jZS5yZWZzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NoZWNrQm94SW5wdXQoZmllbGRSZWZlcmVuY2UucmVmKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRSZWZlcmVuY2UucmVmcy5sZW5ndGggPiAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBmaWVsZFJlZmVyZW5jZS5yZWZzLmZvckVhY2goKGNoZWNrYm94UmVmKSA9PiAoIWNoZWNrYm94UmVmLmRlZmF1bHRDaGVja2VkIHx8ICFjaGVja2JveFJlZi5kaXNhYmxlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNoZWNrYm94UmVmLmNoZWNrZWQgPSBBcnJheS5pc0FycmF5KGZpZWxkVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICEhZmllbGRWYWx1ZS5maW5kKChkYXRhKSA9PiBkYXRhID09PSBjaGVja2JveFJlZi52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZmllbGRWYWx1ZSA9PT0gY2hlY2tib3hSZWYudmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZmllbGRSZWZlcmVuY2UucmVmc1swXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmllbGRSZWZlcmVuY2UucmVmc1swXS5jaGVja2VkID0gISFmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkUmVmZXJlbmNlLnJlZnMuZm9yRWFjaCgocmFkaW9SZWYpID0+IChyYWRpb1JlZi5jaGVja2VkID0gcmFkaW9SZWYudmFsdWUgPT09IGZpZWxkVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0ZpbGVJbnB1dChmaWVsZFJlZmVyZW5jZS5yZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkUmVmZXJlbmNlLnJlZi52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRSZWZlcmVuY2UucmVmLnZhbHVlID0gZmllbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZFJlZmVyZW5jZS5yZWYudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N1YmplY3RzLnZhbHVlcy5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogeyAuLi5fZm9ybVZhbHVlcyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKG9wdGlvbnMuc2hvdWxkRGlydHkgfHwgb3B0aW9ucy5zaG91bGRUb3VjaCkgJiZcbiAgICAgICAgICAgIHVwZGF0ZVRvdWNoQW5kRGlydHkobmFtZSwgZmllbGRWYWx1ZSwgb3B0aW9ucy5zaG91bGRUb3VjaCwgb3B0aW9ucy5zaG91bGREaXJ0eSwgdHJ1ZSk7XG4gICAgICAgIG9wdGlvbnMuc2hvdWxkVmFsaWRhdGUgJiYgdHJpZ2dlcihuYW1lKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldFZhbHVlcyA9IChuYW1lLCB2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkS2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlID0gdmFsdWVbZmllbGRLZXldO1xuICAgICAgICAgICAgY29uc3QgZmllbGROYW1lID0gYCR7bmFtZX0uJHtmaWVsZEtleX1gO1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgZmllbGROYW1lKTtcbiAgICAgICAgICAgIChfbmFtZXMuYXJyYXkuaGFzKG5hbWUpIHx8XG4gICAgICAgICAgICAgICAgIWlzUHJpbWl0aXZlKGZpZWxkVmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgKGZpZWxkICYmICFmaWVsZC5fZikpICYmXG4gICAgICAgICAgICAgICAgIWlzRGF0ZU9iamVjdChmaWVsZFZhbHVlKVxuICAgICAgICAgICAgICAgID8gc2V0VmFsdWVzKGZpZWxkTmFtZSwgZmllbGRWYWx1ZSwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICA6IHNldEZpZWxkVmFsdWUoZmllbGROYW1lLCBmaWVsZFZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0VmFsdWUgPSAobmFtZSwgdmFsdWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgY29uc3QgaXNGaWVsZEFycmF5ID0gX25hbWVzLmFycmF5LmhhcyhuYW1lKTtcbiAgICAgICAgY29uc3QgY2xvbmVWYWx1ZSA9IGNsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgc2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBjbG9uZVZhbHVlKTtcbiAgICAgICAgaWYgKGlzRmllbGRBcnJheSkge1xuICAgICAgICAgICAgX3N1YmplY3RzLmFycmF5Lm5leHQoe1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWVzOiB7IC4uLl9mb3JtVmFsdWVzIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICgoX3Byb3h5Rm9ybVN0YXRlLmlzRGlydHkgfHwgX3Byb3h5Rm9ybVN0YXRlLmRpcnR5RmllbGRzKSAmJlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2hvdWxkRGlydHkpIHtcbiAgICAgICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRpcnR5RmllbGRzOiBnZXREaXJ0eUZpZWxkcyhfZGVmYXVsdFZhbHVlcywgX2Zvcm1WYWx1ZXMpLFxuICAgICAgICAgICAgICAgICAgICBpc0RpcnR5OiBfZ2V0RGlydHkobmFtZSwgY2xvbmVWYWx1ZSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaWVsZCAmJiAhZmllbGQuX2YgJiYgIWlzTnVsbE9yVW5kZWZpbmVkKGNsb25lVmFsdWUpXG4gICAgICAgICAgICAgICAgPyBzZXRWYWx1ZXMobmFtZSwgY2xvbmVWYWx1ZSwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICA6IHNldEZpZWxkVmFsdWUobmFtZSwgY2xvbmVWYWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaXNXYXRjaGVkKG5hbWUsIF9uYW1lcykgJiYgX3N1YmplY3RzLnN0YXRlLm5leHQoeyAuLi5fZm9ybVN0YXRlIH0pO1xuICAgICAgICBfc3ViamVjdHMudmFsdWVzLm5leHQoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHZhbHVlczogeyAuLi5fZm9ybVZhbHVlcyB9LFxuICAgICAgICB9KTtcbiAgICAgICAgIV9zdGF0ZS5tb3VudCAmJiBmbHVzaFJvb3RSZW5kZXIoKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uQ2hhbmdlID0gYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgbGV0IG5hbWUgPSB0YXJnZXQubmFtZTtcbiAgICAgICAgbGV0IGlzRmllbGRWYWx1ZVVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgY29uc3QgZ2V0Q3VycmVudEZpZWxkVmFsdWUgPSAoKSA9PiB0YXJnZXQudHlwZSA/IGdldEZpZWxkVmFsdWUoZmllbGQuX2YpIDogZ2V0RXZlbnRWYWx1ZShldmVudCk7XG4gICAgICAgIGNvbnN0IF91cGRhdGVJc0ZpZWxkVmFsdWVVcGRhdGVkID0gKGZpZWxkVmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlzRmllbGRWYWx1ZVVwZGF0ZWQgPVxuICAgICAgICAgICAgICAgIE51bWJlci5pc05hTihmaWVsZFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICBmaWVsZFZhbHVlID09PSBnZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIGZpZWxkVmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgICAgIGxldCBpc1ZhbGlkO1xuICAgICAgICAgICAgY29uc3QgZmllbGRWYWx1ZSA9IGdldEN1cnJlbnRGaWVsZFZhbHVlKCk7XG4gICAgICAgICAgICBjb25zdCBpc0JsdXJFdmVudCA9IGV2ZW50LnR5cGUgPT09IEVWRU5UUy5CTFVSIHx8IGV2ZW50LnR5cGUgPT09IEVWRU5UUy5GT0NVU19PVVQ7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRTa2lwVmFsaWRhdGlvbiA9ICghaGFzVmFsaWRhdGlvbihmaWVsZC5fZikgJiZcbiAgICAgICAgICAgICAgICAhX29wdGlvbnMucmVzb2x2ZXIgJiZcbiAgICAgICAgICAgICAgICAhZ2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAgICFmaWVsZC5fZi5kZXBzKSB8fFxuICAgICAgICAgICAgICAgIHNraXBWYWxpZGF0aW9uKGlzQmx1ckV2ZW50LCBnZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKSwgX2Zvcm1TdGF0ZS5pc1N1Ym1pdHRlZCwgdmFsaWRhdGlvbk1vZGVBZnRlclN1Ym1pdCwgdmFsaWRhdGlvbk1vZGVCZWZvcmVTdWJtaXQpO1xuICAgICAgICAgICAgY29uc3Qgd2F0Y2hlZCA9IGlzV2F0Y2hlZChuYW1lLCBfbmFtZXMsIGlzQmx1ckV2ZW50KTtcbiAgICAgICAgICAgIHNldChfZm9ybVZhbHVlcywgbmFtZSwgZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoaXNCbHVyRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBmaWVsZC5fZi5vbkJsdXIgJiYgZmllbGQuX2Yub25CbHVyKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBkZWxheUVycm9yQ2FsbGJhY2sgJiYgZGVsYXlFcnJvckNhbGxiYWNrKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQuX2Yub25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBmaWVsZC5fZi5vbkNoYW5nZShldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaWVsZFN0YXRlID0gdXBkYXRlVG91Y2hBbmREaXJ0eShuYW1lLCBmaWVsZFZhbHVlLCBpc0JsdXJFdmVudCwgZmFsc2UpO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkUmVuZGVyID0gIWlzRW1wdHlPYmplY3QoZmllbGRTdGF0ZSkgfHwgd2F0Y2hlZDtcbiAgICAgICAgICAgICFpc0JsdXJFdmVudCAmJlxuICAgICAgICAgICAgICAgIF9zdWJqZWN0cy52YWx1ZXMubmV4dCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGV2ZW50LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogeyAuLi5fZm9ybVZhbHVlcyB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHNob3VsZFNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQgJiYgX3VwZGF0ZVZhbGlkKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChzaG91bGRSZW5kZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoeyBuYW1lLCAuLi4od2F0Y2hlZCA/IHt9IDogZmllbGRTdGF0ZSkgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgIWlzQmx1ckV2ZW50ICYmIHdhdGNoZWQgJiYgX3N1YmplY3RzLnN0YXRlLm5leHQoeyAuLi5fZm9ybVN0YXRlIH0pO1xuICAgICAgICAgICAgX3VwZGF0ZUlzVmFsaWRhdGluZyh0cnVlKTtcbiAgICAgICAgICAgIGlmIChfb3B0aW9ucy5yZXNvbHZlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3JzIH0gPSBhd2FpdCBfZXhlY3V0ZVNjaGVtYShbbmFtZV0pO1xuICAgICAgICAgICAgICAgIF91cGRhdGVJc0ZpZWxkVmFsdWVVcGRhdGVkKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChpc0ZpZWxkVmFsdWVVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzRXJyb3JMb29rdXBSZXN1bHQgPSBzY2hlbWFFcnJvckxvb2t1cChfZm9ybVN0YXRlLmVycm9ycywgX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTG9va3VwUmVzdWx0ID0gc2NoZW1hRXJyb3JMb29rdXAoZXJyb3JzLCBfZmllbGRzLCBwcmV2aW91c0Vycm9yTG9va3VwUmVzdWx0Lm5hbWUgfHwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gZXJyb3JMb29rdXBSZXN1bHQuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBlcnJvckxvb2t1cFJlc3VsdC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gaXNFbXB0eU9iamVjdChlcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yID0gKGF3YWl0IHZhbGlkYXRlRmllbGQoZmllbGQsIF9mb3JtVmFsdWVzLCBzaG91bGREaXNwbGF5QWxsQXNzb2NpYXRlZEVycm9ycywgX29wdGlvbnMuc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbikpW25hbWVdO1xuICAgICAgICAgICAgICAgIF91cGRhdGVJc0ZpZWxkVmFsdWVVcGRhdGVkKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChpc0ZpZWxkVmFsdWVVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gYXdhaXQgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uKF9maWVsZHMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRmllbGRWYWx1ZVVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICBmaWVsZC5fZi5kZXBzICYmXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIoZmllbGQuX2YuZGVwcyk7XG4gICAgICAgICAgICAgICAgc2hvdWxkUmVuZGVyQnlFcnJvcihuYW1lLCBpc1ZhbGlkLCBlcnJvciwgZmllbGRTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IF9mb2N1c0lucHV0ID0gKHJlZiwga2V5KSA9PiB7XG4gICAgICAgIGlmIChnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIGtleSkgJiYgcmVmLmZvY3VzKSB7XG4gICAgICAgICAgICByZWYuZm9jdXMoKTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIGNvbnN0IHRyaWdnZXIgPSBhc3luYyAobmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGxldCBpc1ZhbGlkO1xuICAgICAgICBsZXQgdmFsaWRhdGlvblJlc3VsdDtcbiAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IGNvbnZlcnRUb0FycmF5UGF5bG9hZChuYW1lKTtcbiAgICAgICAgX3VwZGF0ZUlzVmFsaWRhdGluZyh0cnVlKTtcbiAgICAgICAgaWYgKF9vcHRpb25zLnJlc29sdmVyKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBhd2FpdCBleGVjdXRlU2NoZW1hQW5kVXBkYXRlU3RhdGUoaXNVbmRlZmluZWQobmFtZSkgPyBuYW1lIDogZmllbGROYW1lcyk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gaXNFbXB0eU9iamVjdChlcnJvcnMpO1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdCA9IG5hbWVcbiAgICAgICAgICAgICAgICA/ICFmaWVsZE5hbWVzLnNvbWUoKG5hbWUpID0+IGdldChlcnJvcnMsIG5hbWUpKVxuICAgICAgICAgICAgICAgIDogaXNWYWxpZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0ID0gKGF3YWl0IFByb21pc2UuYWxsKGZpZWxkTmFtZXMubWFwKGFzeW5jIChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24oZmllbGQgJiYgZmllbGQuX2YgPyB7IFtmaWVsZE5hbWVdOiBmaWVsZCB9IDogZmllbGQpO1xuICAgICAgICAgICAgfSkpKS5ldmVyeShCb29sZWFuKTtcbiAgICAgICAgICAgICEoIXZhbGlkYXRpb25SZXN1bHQgJiYgIV9mb3JtU3RhdGUuaXNWYWxpZCkgJiYgX3VwZGF0ZVZhbGlkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0ID0gaXNWYWxpZCA9IGF3YWl0IGV4ZWN1dGVCdWlsdEluVmFsaWRhdGlvbihfZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAuLi4oIWlzU3RyaW5nKG5hbWUpIHx8XG4gICAgICAgICAgICAgICAgKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkICYmIGlzVmFsaWQgIT09IF9mb3JtU3RhdGUuaXNWYWxpZClcbiAgICAgICAgICAgICAgICA/IHt9XG4gICAgICAgICAgICAgICAgOiB7IG5hbWUgfSksXG4gICAgICAgICAgICAuLi4oX29wdGlvbnMucmVzb2x2ZXIgfHwgIW5hbWUgPyB7IGlzVmFsaWQgfSA6IHt9KSxcbiAgICAgICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgICAgICBpc1ZhbGlkYXRpbmc6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgb3B0aW9ucy5zaG91bGRGb2N1cyAmJlxuICAgICAgICAgICAgIXZhbGlkYXRpb25SZXN1bHQgJiZcbiAgICAgICAgICAgIGl0ZXJhdGVGaWVsZHNCeUFjdGlvbihfZmllbGRzLCBfZm9jdXNJbnB1dCwgbmFtZSA/IGZpZWxkTmFtZXMgOiBfbmFtZXMubW91bnQpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGlvblJlc3VsdDtcbiAgICB9O1xuICAgIGNvbnN0IGdldFZhbHVlcyA9IChmaWVsZE5hbWVzKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHtcbiAgICAgICAgICAgIC4uLl9kZWZhdWx0VmFsdWVzLFxuICAgICAgICAgICAgLi4uKF9zdGF0ZS5tb3VudCA/IF9mb3JtVmFsdWVzIDoge30pLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXNVbmRlZmluZWQoZmllbGROYW1lcylcbiAgICAgICAgICAgID8gdmFsdWVzXG4gICAgICAgICAgICA6IGlzU3RyaW5nKGZpZWxkTmFtZXMpXG4gICAgICAgICAgICAgICAgPyBnZXQodmFsdWVzLCBmaWVsZE5hbWVzKVxuICAgICAgICAgICAgICAgIDogZmllbGROYW1lcy5tYXAoKG5hbWUpID0+IGdldCh2YWx1ZXMsIG5hbWUpKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEZpZWxkU3RhdGUgPSAobmFtZSwgZm9ybVN0YXRlKSA9PiAoe1xuICAgICAgICBpbnZhbGlkOiAhIWdldCgoZm9ybVN0YXRlIHx8IF9mb3JtU3RhdGUpLmVycm9ycywgbmFtZSksXG4gICAgICAgIGlzRGlydHk6ICEhZ2V0KChmb3JtU3RhdGUgfHwgX2Zvcm1TdGF0ZSkuZGlydHlGaWVsZHMsIG5hbWUpLFxuICAgICAgICBpc1RvdWNoZWQ6ICEhZ2V0KChmb3JtU3RhdGUgfHwgX2Zvcm1TdGF0ZSkudG91Y2hlZEZpZWxkcywgbmFtZSksXG4gICAgICAgIGVycm9yOiBnZXQoKGZvcm1TdGF0ZSB8fCBfZm9ybVN0YXRlKS5lcnJvcnMsIG5hbWUpLFxuICAgIH0pO1xuICAgIGNvbnN0IGNsZWFyRXJyb3JzID0gKG5hbWUpID0+IHtcbiAgICAgICAgbmFtZSAmJlxuICAgICAgICAgICAgY29udmVydFRvQXJyYXlQYXlsb2FkKG5hbWUpLmZvckVhY2goKGlucHV0TmFtZSkgPT4gdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIGlucHV0TmFtZSkpO1xuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICBlcnJvcnM6IG5hbWUgPyBfZm9ybVN0YXRlLmVycm9ycyA6IHt9LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHNldEVycm9yID0gKG5hbWUsIGVycm9yLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlZiA9IChnZXQoX2ZpZWxkcywgbmFtZSwgeyBfZjoge30gfSkuX2YgfHwge30pLnJlZjtcbiAgICAgICAgc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lLCB7XG4gICAgICAgICAgICAuLi5lcnJvcixcbiAgICAgICAgICAgIHJlZixcbiAgICAgICAgfSk7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBlcnJvcnM6IF9mb3JtU3RhdGUuZXJyb3JzLFxuICAgICAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMuc2hvdWxkRm9jdXMgJiYgcmVmICYmIHJlZi5mb2N1cyAmJiByZWYuZm9jdXMoKTtcbiAgICB9O1xuICAgIGNvbnN0IHdhdGNoID0gKG5hbWUsIGRlZmF1bHRWYWx1ZSkgPT4gaXNGdW5jdGlvbihuYW1lKVxuICAgICAgICA/IF9zdWJqZWN0cy52YWx1ZXMuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgIG5leHQ6IChwYXlsb2FkKSA9PiBuYW1lKF9nZXRXYXRjaCh1bmRlZmluZWQsIGRlZmF1bHRWYWx1ZSksIHBheWxvYWQpLFxuICAgICAgICB9KVxuICAgICAgICA6IF9nZXRXYXRjaChuYW1lLCBkZWZhdWx0VmFsdWUsIHRydWUpO1xuICAgIGNvbnN0IHVucmVnaXN0ZXIgPSAobmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIG5hbWUgPyBjb252ZXJ0VG9BcnJheVBheWxvYWQobmFtZSkgOiBfbmFtZXMubW91bnQpIHtcbiAgICAgICAgICAgIF9uYW1lcy5tb3VudC5kZWxldGUoZmllbGROYW1lKTtcbiAgICAgICAgICAgIF9uYW1lcy5hcnJheS5kZWxldGUoZmllbGROYW1lKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5rZWVwVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB1bnNldChfZmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIHVuc2V0KF9mb3JtVmFsdWVzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgIW9wdGlvbnMua2VlcEVycm9yICYmIHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgIW9wdGlvbnMua2VlcERpcnR5ICYmIHVuc2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAhb3B0aW9ucy5rZWVwVG91Y2hlZCAmJiB1bnNldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAhX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlciAmJlxuICAgICAgICAgICAgICAgICFvcHRpb25zLmtlZXBEZWZhdWx0VmFsdWUgJiZcbiAgICAgICAgICAgICAgICB1bnNldChfZGVmYXVsdFZhbHVlcywgZmllbGROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBfc3ViamVjdHMudmFsdWVzLm5leHQoe1xuICAgICAgICAgICAgdmFsdWVzOiB7IC4uLl9mb3JtVmFsdWVzIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAuLi5fZm9ybVN0YXRlLFxuICAgICAgICAgICAgLi4uKCFvcHRpb25zLmtlZXBEaXJ0eSA/IHt9IDogeyBpc0RpcnR5OiBfZ2V0RGlydHkoKSB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgICFvcHRpb25zLmtlZXBJc1ZhbGlkICYmIF91cGRhdGVWYWxpZCgpO1xuICAgIH07XG4gICAgY29uc3QgX3VwZGF0ZURpc2FibGVkRmllbGQgPSAoeyBkaXNhYmxlZCwgbmFtZSwgZmllbGQsIGZpZWxkcywgdmFsdWUsIH0pID0+IHtcbiAgICAgICAgaWYgKGlzQm9vbGVhbihkaXNhYmxlZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0VmFsdWUgPSBkaXNhYmxlZFxuICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgOiBpc1VuZGVmaW5lZCh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgPyBnZXRGaWVsZFZhbHVlKGZpZWxkID8gZmllbGQuX2YgOiBnZXQoZmllbGRzLCBuYW1lKS5fZilcbiAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZTtcbiAgICAgICAgICAgIHNldChfZm9ybVZhbHVlcywgbmFtZSwgaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgICB1cGRhdGVUb3VjaEFuZERpcnR5KG5hbWUsIGlucHV0VmFsdWUsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyID0gKG5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBsZXQgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGNvbnN0IGRpc2FibGVkSXNEZWZpbmVkID0gaXNCb29sZWFuKG9wdGlvbnMuZGlzYWJsZWQpO1xuICAgICAgICBzZXQoX2ZpZWxkcywgbmFtZSwge1xuICAgICAgICAgICAgLi4uKGZpZWxkIHx8IHt9KSxcbiAgICAgICAgICAgIF9mOiB7XG4gICAgICAgICAgICAgICAgLi4uKGZpZWxkICYmIGZpZWxkLl9mID8gZmllbGQuX2YgOiB7IHJlZjogeyBuYW1lIH0gfSksXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBtb3VudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIF9uYW1lcy5tb3VudC5hZGQobmFtZSk7XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgX3VwZGF0ZURpc2FibGVkRmllbGQoe1xuICAgICAgICAgICAgICAgIGZpZWxkLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBvcHRpb25zLmRpc2FibGVkLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMudmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZVZhbGlkQW5kVmFsdWUobmFtZSwgdHJ1ZSwgb3B0aW9ucy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLihkaXNhYmxlZElzRGVmaW5lZCA/IHsgZGlzYWJsZWQ6IG9wdGlvbnMuZGlzYWJsZWQgfSA6IHt9KSxcbiAgICAgICAgICAgIC4uLihfb3B0aW9ucy5wcm9ncmVzc2l2ZVxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogISFvcHRpb25zLnJlcXVpcmVkLFxuICAgICAgICAgICAgICAgICAgICBtaW46IGdldFJ1bGVWYWx1ZShvcHRpb25zLm1pbiksXG4gICAgICAgICAgICAgICAgICAgIG1heDogZ2V0UnVsZVZhbHVlKG9wdGlvbnMubWF4KSxcbiAgICAgICAgICAgICAgICAgICAgbWluTGVuZ3RoOiBnZXRSdWxlVmFsdWUob3B0aW9ucy5taW5MZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICBtYXhMZW5ndGg6IGdldFJ1bGVWYWx1ZShvcHRpb25zLm1heExlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGdldFJ1bGVWYWx1ZShvcHRpb25zLnBhdHRlcm4pLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBvbkNoYW5nZSxcbiAgICAgICAgICAgIG9uQmx1cjogb25DaGFuZ2UsXG4gICAgICAgICAgICByZWY6IChyZWYpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyKG5hbWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGRSZWYgPSBpc1VuZGVmaW5lZChyZWYudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlZi5xdWVyeVNlbGVjdG9yQWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZWYucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQsc2VsZWN0LHRleHRhcmVhJylbMF0gfHwgcmVmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZWZcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVmO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByYWRpb09yQ2hlY2tib3ggPSBpc1JhZGlvT3JDaGVja2JveChmaWVsZFJlZik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZnMgPSBmaWVsZC5fZi5yZWZzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFkaW9PckNoZWNrYm94XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlZnMuZmluZCgob3B0aW9uKSA9PiBvcHRpb24gPT09IGZpZWxkUmVmKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBmaWVsZFJlZiA9PT0gZmllbGQuX2YucmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0KF9maWVsZHMsIG5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZmllbGQuX2YsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uKHJhZGlvT3JDaGVja2JveFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5yZWZzLmZpbHRlcihsaXZlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4oQXJyYXkuaXNBcnJheShnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUpKSA/IFt7fV0gOiBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiB7IHR5cGU6IGZpZWxkUmVmLnR5cGUsIG5hbWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHsgcmVmOiBmaWVsZFJlZiB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVWYWxpZEFuZFZhbHVlKG5hbWUsIGZhbHNlLCB1bmRlZmluZWQsIGZpZWxkUmVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUsIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLl9mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC5fZi5tb3VudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIChfb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyIHx8IG9wdGlvbnMuc2hvdWxkVW5yZWdpc3RlcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICEoaXNOYW1lSW5GaWVsZEFycmF5KF9uYW1lcy5hcnJheSwgbmFtZSkgJiYgX3N0YXRlLmFjdGlvbikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIF9uYW1lcy51bk1vdW50LmFkZChuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgX2ZvY3VzRXJyb3IgPSAoKSA9PiBfb3B0aW9ucy5zaG91bGRGb2N1c0Vycm9yICYmXG4gICAgICAgIGl0ZXJhdGVGaWVsZHNCeUFjdGlvbihfZmllbGRzLCBfZm9jdXNJbnB1dCwgX25hbWVzLm1vdW50KTtcbiAgICBjb25zdCBfZGlzYWJsZUZvcm0gPSAoZGlzYWJsZWQpID0+IHtcbiAgICAgICAgaWYgKGlzQm9vbGVhbihkaXNhYmxlZCkpIHtcbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHsgZGlzYWJsZWQgfSk7XG4gICAgICAgICAgICBpdGVyYXRlRmllbGRzQnlBY3Rpb24oX2ZpZWxkcywgKHJlZiwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCByZXF1aXJlZERpc2FibGVkU3RhdGUgPSBkaXNhYmxlZDtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRGaWVsZCAmJiBpc0Jvb2xlYW4oY3VycmVudEZpZWxkLl9mLmRpc2FibGVkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZERpc2FibGVkU3RhdGUgfHwgKHJlcXVpcmVkRGlzYWJsZWRTdGF0ZSA9IGN1cnJlbnRGaWVsZC5fZi5kaXNhYmxlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlZi5kaXNhYmxlZCA9IHJlcXVpcmVkRGlzYWJsZWRTdGF0ZTtcbiAgICAgICAgICAgIH0sIDAsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlU3VibWl0ID0gKG9uVmFsaWQsIG9uSW52YWxpZCkgPT4gYXN5bmMgKGUpID0+IHtcbiAgICAgICAgbGV0IG9uVmFsaWRFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5wZXJzaXN0ICYmIGUucGVyc2lzdCgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaWVsZFZhbHVlcyA9IGNsb25lT2JqZWN0KF9mb3JtVmFsdWVzKTtcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgaXNTdWJtaXR0aW5nOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKF9vcHRpb25zLnJlc29sdmVyKSB7XG4gICAgICAgICAgICBjb25zdCB7IGVycm9ycywgdmFsdWVzIH0gPSBhd2FpdCBfZXhlY3V0ZVNjaGVtYSgpO1xuICAgICAgICAgICAgX2Zvcm1TdGF0ZS5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgICAgICBmaWVsZFZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IGV4ZWN1dGVCdWlsdEluVmFsaWRhdGlvbihfZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgICB1bnNldChfZm9ybVN0YXRlLmVycm9ycywgJ3Jvb3QnKTtcbiAgICAgICAgaWYgKGlzRW1wdHlPYmplY3QoX2Zvcm1TdGF0ZS5lcnJvcnMpKSB7XG4gICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgZXJyb3JzOiB7fSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBvblZhbGlkKGZpZWxkVmFsdWVzLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG9uVmFsaWRFcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9uSW52YWxpZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG9uSW52YWxpZCh7IC4uLl9mb3JtU3RhdGUuZXJyb3JzIH0sIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2ZvY3VzRXJyb3IoKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoX2ZvY3VzRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIGlzU3VibWl0dGVkOiB0cnVlLFxuICAgICAgICAgICAgaXNTdWJtaXR0aW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGlzU3VibWl0U3VjY2Vzc2Z1bDogaXNFbXB0eU9iamVjdChfZm9ybVN0YXRlLmVycm9ycykgJiYgIW9uVmFsaWRFcnJvcixcbiAgICAgICAgICAgIHN1Ym1pdENvdW50OiBfZm9ybVN0YXRlLnN1Ym1pdENvdW50ICsgMSxcbiAgICAgICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob25WYWxpZEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBvblZhbGlkRXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlc2V0RmllbGQgPSAobmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGlmIChnZXQoX2ZpZWxkcywgbmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChvcHRpb25zLmRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBzZXRWYWx1ZShuYW1lLCBjbG9uZU9iamVjdChnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRWYWx1ZShuYW1lLCBvcHRpb25zLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgc2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lLCBjbG9uZU9iamVjdChvcHRpb25zLmRlZmF1bHRWYWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmtlZXBUb3VjaGVkKSB7XG4gICAgICAgICAgICAgICAgdW5zZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5rZWVwRGlydHkpIHtcbiAgICAgICAgICAgICAgICB1bnNldChfZm9ybVN0YXRlLmRpcnR5RmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBfZm9ybVN0YXRlLmlzRGlydHkgPSBvcHRpb25zLmRlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICA/IF9nZXREaXJ0eShuYW1lLCBjbG9uZU9iamVjdChnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUpKSlcbiAgICAgICAgICAgICAgICAgICAgOiBfZ2V0RGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5rZWVwRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB1bnNldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICAgICAgX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQgJiYgX3VwZGF0ZVZhbGlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7IC4uLl9mb3JtU3RhdGUgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IF9yZXNldCA9IChmb3JtVmFsdWVzLCBrZWVwU3RhdGVPcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlZFZhbHVlcyA9IGZvcm1WYWx1ZXMgPyBjbG9uZU9iamVjdChmb3JtVmFsdWVzKSA6IF9kZWZhdWx0VmFsdWVzO1xuICAgICAgICBjb25zdCBjbG9uZVVwZGF0ZWRWYWx1ZXMgPSBjbG9uZU9iamVjdCh1cGRhdGVkVmFsdWVzKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gZm9ybVZhbHVlcyAmJiAhaXNFbXB0eU9iamVjdChmb3JtVmFsdWVzKVxuICAgICAgICAgICAgPyBjbG9uZVVwZGF0ZWRWYWx1ZXNcbiAgICAgICAgICAgIDogX2RlZmF1bHRWYWx1ZXM7XG4gICAgICAgIGlmICgha2VlcFN0YXRlT3B0aW9ucy5rZWVwRGVmYXVsdFZhbHVlcykge1xuICAgICAgICAgICAgX2RlZmF1bHRWYWx1ZXMgPSB1cGRhdGVkVmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICgha2VlcFN0YXRlT3B0aW9ucy5rZWVwVmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoa2VlcFN0YXRlT3B0aW9ucy5rZWVwRGlydHlWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBvZiBfbmFtZXMubW91bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIGZpZWxkTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2V0KHZhbHVlcywgZmllbGROYW1lLCBnZXQoX2Zvcm1WYWx1ZXMsIGZpZWxkTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNldFZhbHVlKGZpZWxkTmFtZSwgZ2V0KHZhbHVlcywgZmllbGROYW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzV2ViICYmIGlzVW5kZWZpbmVkKGZvcm1WYWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBfbmFtZXMubW91bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLl9mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGRSZWZlcmVuY2UgPSBBcnJheS5pc0FycmF5KGZpZWxkLl9mLnJlZnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZmllbGQuX2YucmVmc1swXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZpZWxkLl9mLnJlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNIVE1MRWxlbWVudChmaWVsZFJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybSA9IGZpZWxkUmVmZXJlbmNlLmNsb3Nlc3QoJ2Zvcm0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0ucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9maWVsZHMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9mb3JtVmFsdWVzID0gcHJvcHMuc2hvdWxkVW5yZWdpc3RlclxuICAgICAgICAgICAgICAgID8ga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGVmYXVsdFZhbHVlc1xuICAgICAgICAgICAgICAgICAgICA/IGNsb25lT2JqZWN0KF9kZWZhdWx0VmFsdWVzKVxuICAgICAgICAgICAgICAgICAgICA6IHt9XG4gICAgICAgICAgICAgICAgOiBjbG9uZU9iamVjdCh2YWx1ZXMpO1xuICAgICAgICAgICAgX3N1YmplY3RzLmFycmF5Lm5leHQoe1xuICAgICAgICAgICAgICAgIHZhbHVlczogeyAuLi52YWx1ZXMgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3N1YmplY3RzLnZhbHVlcy5uZXh0KHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHsgLi4udmFsdWVzIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfbmFtZXMgPSB7XG4gICAgICAgICAgICBtb3VudDogbmV3IFNldCgpLFxuICAgICAgICAgICAgdW5Nb3VudDogbmV3IFNldCgpLFxuICAgICAgICAgICAgYXJyYXk6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIHdhdGNoOiBuZXcgU2V0KCksXG4gICAgICAgICAgICB3YXRjaEFsbDogZmFsc2UsXG4gICAgICAgICAgICBmb2N1czogJycsXG4gICAgICAgIH07XG4gICAgICAgICFfc3RhdGUubW91bnQgJiYgZmx1c2hSb290UmVuZGVyKCk7XG4gICAgICAgIF9zdGF0ZS5tb3VudCA9XG4gICAgICAgICAgICAhX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQgfHxcbiAgICAgICAgICAgICAgICAhIWtlZXBTdGF0ZU9wdGlvbnMua2VlcElzVmFsaWQgfHxcbiAgICAgICAgICAgICAgICAhIWtlZXBTdGF0ZU9wdGlvbnMua2VlcERpcnR5VmFsdWVzO1xuICAgICAgICBfc3RhdGUud2F0Y2ggPSAhIXByb3BzLnNob3VsZFVucmVnaXN0ZXI7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIHN1Ym1pdENvdW50OiBrZWVwU3RhdGVPcHRpb25zLmtlZXBTdWJtaXRDb3VudFxuICAgICAgICAgICAgICAgID8gX2Zvcm1TdGF0ZS5zdWJtaXRDb3VudFxuICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIGlzRGlydHk6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcERpcnR5XG4gICAgICAgICAgICAgICAgPyBfZm9ybVN0YXRlLmlzRGlydHlcbiAgICAgICAgICAgICAgICA6ICEhKGtlZXBTdGF0ZU9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgIWRlZXBFcXVhbChmb3JtVmFsdWVzLCBfZGVmYXVsdFZhbHVlcykpLFxuICAgICAgICAgICAgaXNTdWJtaXR0ZWQ6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcElzU3VibWl0dGVkXG4gICAgICAgICAgICAgICAgPyBfZm9ybVN0YXRlLmlzU3VibWl0dGVkXG4gICAgICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGRpcnR5RmllbGRzOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBEaXJ0eVZhbHVlc1xuICAgICAgICAgICAgICAgID8ga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGVmYXVsdFZhbHVlcyAmJiBfZm9ybVZhbHVlc1xuICAgICAgICAgICAgICAgICAgICA/IGdldERpcnR5RmllbGRzKF9kZWZhdWx0VmFsdWVzLCBfZm9ybVZhbHVlcylcbiAgICAgICAgICAgICAgICAgICAgOiBfZm9ybVN0YXRlLmRpcnR5RmllbGRzXG4gICAgICAgICAgICAgICAgOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBEZWZhdWx0VmFsdWVzICYmIGZvcm1WYWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgPyBnZXREaXJ0eUZpZWxkcyhfZGVmYXVsdFZhbHVlcywgZm9ybVZhbHVlcylcbiAgICAgICAgICAgICAgICAgICAgOiB7fSxcbiAgICAgICAgICAgIHRvdWNoZWRGaWVsZHM6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcFRvdWNoZWRcbiAgICAgICAgICAgICAgICA/IF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkc1xuICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgICAgICBlcnJvcnM6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcEVycm9ycyA/IF9mb3JtU3RhdGUuZXJyb3JzIDoge30sXG4gICAgICAgICAgICBpc1N1Ym1pdFN1Y2Nlc3NmdWw6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcElzU3VibWl0U3VjY2Vzc2Z1bFxuICAgICAgICAgICAgICAgID8gX2Zvcm1TdGF0ZS5pc1N1Ym1pdFN1Y2Nlc3NmdWxcbiAgICAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgaXNTdWJtaXR0aW5nOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZXNldCA9IChmb3JtVmFsdWVzLCBrZWVwU3RhdGVPcHRpb25zKSA9PiBfcmVzZXQoaXNGdW5jdGlvbihmb3JtVmFsdWVzKVxuICAgICAgICA/IGZvcm1WYWx1ZXMoX2Zvcm1WYWx1ZXMpXG4gICAgICAgIDogZm9ybVZhbHVlcywga2VlcFN0YXRlT3B0aW9ucyk7XG4gICAgY29uc3Qgc2V0Rm9jdXMgPSAobmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICBjb25zdCBmaWVsZFJlZmVyZW5jZSA9IGZpZWxkICYmIGZpZWxkLl9mO1xuICAgICAgICBpZiAoZmllbGRSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkUmVmID0gZmllbGRSZWZlcmVuY2UucmVmc1xuICAgICAgICAgICAgICAgID8gZmllbGRSZWZlcmVuY2UucmVmc1swXVxuICAgICAgICAgICAgICAgIDogZmllbGRSZWZlcmVuY2UucmVmO1xuICAgICAgICAgICAgaWYgKGZpZWxkUmVmLmZvY3VzKSB7XG4gICAgICAgICAgICAgICAgZmllbGRSZWYuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNob3VsZFNlbGVjdCAmJiBmaWVsZFJlZi5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgX3VwZGF0ZUZvcm1TdGF0ZSA9ICh1cGRhdGVkRm9ybVN0YXRlKSA9PiB7XG4gICAgICAgIF9mb3JtU3RhdGUgPSB7XG4gICAgICAgICAgICAuLi5fZm9ybVN0YXRlLFxuICAgICAgICAgICAgLi4udXBkYXRlZEZvcm1TdGF0ZSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IF9yZXNldERlZmF1bHRWYWx1ZXMgPSAoKSA9PiBpc0Z1bmN0aW9uKF9vcHRpb25zLmRlZmF1bHRWYWx1ZXMpICYmXG4gICAgICAgIF9vcHRpb25zLmRlZmF1bHRWYWx1ZXMoKS50aGVuKCh2YWx1ZXMpID0+IHtcbiAgICAgICAgICAgIHJlc2V0KHZhbHVlcywgX29wdGlvbnMucmVzZXRPcHRpb25zKTtcbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgICAgIHJlZ2lzdGVyLFxuICAgICAgICAgICAgdW5yZWdpc3RlcixcbiAgICAgICAgICAgIGdldEZpZWxkU3RhdGUsXG4gICAgICAgICAgICBoYW5kbGVTdWJtaXQsXG4gICAgICAgICAgICBzZXRFcnJvcixcbiAgICAgICAgICAgIF9leGVjdXRlU2NoZW1hLFxuICAgICAgICAgICAgX2dldFdhdGNoLFxuICAgICAgICAgICAgX2dldERpcnR5LFxuICAgICAgICAgICAgX3VwZGF0ZVZhbGlkLFxuICAgICAgICAgICAgX3JlbW92ZVVubW91bnRlZCxcbiAgICAgICAgICAgIF91cGRhdGVGaWVsZEFycmF5LFxuICAgICAgICAgICAgX3VwZGF0ZURpc2FibGVkRmllbGQsXG4gICAgICAgICAgICBfZ2V0RmllbGRBcnJheSxcbiAgICAgICAgICAgIF9yZXNldCxcbiAgICAgICAgICAgIF9yZXNldERlZmF1bHRWYWx1ZXMsXG4gICAgICAgICAgICBfdXBkYXRlRm9ybVN0YXRlLFxuICAgICAgICAgICAgX2Rpc2FibGVGb3JtLFxuICAgICAgICAgICAgX3N1YmplY3RzLFxuICAgICAgICAgICAgX3Byb3h5Rm9ybVN0YXRlLFxuICAgICAgICAgICAgX3NldEVycm9ycyxcbiAgICAgICAgICAgIGdldCBfZmllbGRzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZmllbGRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBfZm9ybVZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2Zvcm1WYWx1ZXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IF9zdGF0ZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N0YXRlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCBfc3RhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfc3RhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgX2RlZmF1bHRWYWx1ZXMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9kZWZhdWx0VmFsdWVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBfbmFtZXMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9uYW1lcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgX25hbWVzKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX25hbWVzID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IF9mb3JtU3RhdGUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mb3JtU3RhdGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0IF9mb3JtU3RhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfZm9ybVN0YXRlID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IF9vcHRpb25zKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfb3B0aW9ucztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgX29wdGlvbnModmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uX29wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB0cmlnZ2VyLFxuICAgICAgICByZWdpc3RlcixcbiAgICAgICAgaGFuZGxlU3VibWl0LFxuICAgICAgICB3YXRjaCxcbiAgICAgICAgc2V0VmFsdWUsXG4gICAgICAgIGdldFZhbHVlcyxcbiAgICAgICAgcmVzZXQsXG4gICAgICAgIHJlc2V0RmllbGQsXG4gICAgICAgIGNsZWFyRXJyb3JzLFxuICAgICAgICB1bnJlZ2lzdGVyLFxuICAgICAgICBzZXRFcnJvcixcbiAgICAgICAgc2V0Rm9jdXMsXG4gICAgICAgIGdldEZpZWxkU3RhdGUsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBDdXN0b20gaG9vayB0byBtYW5hZ2UgdGhlIGVudGlyZSBmb3JtLlxuICpcbiAqIEByZW1hcmtzXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2Vmb3JtKSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tZ2V0LXN0YXJ0ZWQtdHMtNWtzbW0pIOKAoiBbVmlkZW9dKGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9UmtYdjRBWFhDXzQpXG4gKlxuICogQHBhcmFtIHByb3BzIC0gZm9ybSBjb25maWd1cmF0aW9uIGFuZCB2YWxpZGF0aW9uIHBhcmFtZXRlcnMuXG4gKlxuICogQHJldHVybnMgbWV0aG9kcyAtIGluZGl2aWR1YWwgZnVuY3Rpb25zIHRvIG1hbmFnZSB0aGUgZm9ybSBzdGF0ZS4ge0BsaW5rIFVzZUZvcm1SZXR1cm59XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCB7IHJlZ2lzdGVyLCBoYW5kbGVTdWJtaXQsIHdhdGNoLCBmb3JtU3RhdGU6IHsgZXJyb3JzIH0gfSA9IHVzZUZvcm0oKTtcbiAqICAgY29uc3Qgb25TdWJtaXQgPSBkYXRhID0+IGNvbnNvbGUubG9nKGRhdGEpO1xuICpcbiAqICAgY29uc29sZS5sb2cod2F0Y2goXCJleGFtcGxlXCIpKTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGZvcm0gb25TdWJtaXQ9e2hhbmRsZVN1Ym1pdChvblN1Ym1pdCl9PlxuICogICAgICAgPGlucHV0IGRlZmF1bHRWYWx1ZT1cInRlc3RcIiB7Li4ucmVnaXN0ZXIoXCJleGFtcGxlXCIpfSAvPlxuICogICAgICAgPGlucHV0IHsuLi5yZWdpc3RlcihcImV4YW1wbGVSZXF1aXJlZFwiLCB7IHJlcXVpcmVkOiB0cnVlIH0pfSAvPlxuICogICAgICAge2Vycm9ycy5leGFtcGxlUmVxdWlyZWQgJiYgPHNwYW4+VGhpcyBmaWVsZCBpcyByZXF1aXJlZDwvc3Bhbj59XG4gKiAgICAgICA8YnV0dG9uPlN1Ym1pdDwvYnV0dG9uPlxuICogICAgIDwvZm9ybT5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VGb3JtKHByb3BzID0ge30pIHtcbiAgICBjb25zdCBfZm9ybUNvbnRyb2wgPSBSZWFjdC51c2VSZWYoKTtcbiAgICBjb25zdCBfdmFsdWVzID0gUmVhY3QudXNlUmVmKCk7XG4gICAgY29uc3QgW2Zvcm1TdGF0ZSwgdXBkYXRlRm9ybVN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICAgICAgaXNEaXJ0eTogZmFsc2UsXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXG4gICAgICAgIGlzTG9hZGluZzogaXNGdW5jdGlvbihwcm9wcy5kZWZhdWx0VmFsdWVzKSxcbiAgICAgICAgaXNTdWJtaXR0ZWQ6IGZhbHNlLFxuICAgICAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlLFxuICAgICAgICBpc1N1Ym1pdFN1Y2Nlc3NmdWw6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgc3VibWl0Q291bnQ6IDAsXG4gICAgICAgIGRpcnR5RmllbGRzOiB7fSxcbiAgICAgICAgdG91Y2hlZEZpZWxkczoge30sXG4gICAgICAgIGVycm9yczogcHJvcHMuZXJyb3JzIHx8IHt9LFxuICAgICAgICBkaXNhYmxlZDogcHJvcHMuZGlzYWJsZWQgfHwgZmFsc2UsXG4gICAgICAgIGRlZmF1bHRWYWx1ZXM6IGlzRnVuY3Rpb24ocHJvcHMuZGVmYXVsdFZhbHVlcylcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IHByb3BzLmRlZmF1bHRWYWx1ZXMsXG4gICAgfSk7XG4gICAgaWYgKCFfZm9ybUNvbnRyb2wuY3VycmVudCkge1xuICAgICAgICBfZm9ybUNvbnRyb2wuY3VycmVudCA9IHtcbiAgICAgICAgICAgIC4uLmNyZWF0ZUZvcm1Db250cm9sKHByb3BzLCAoKSA9PiB1cGRhdGVGb3JtU3RhdGUoKGZvcm1TdGF0ZSkgPT4gKHsgLi4uZm9ybVN0YXRlIH0pKSksXG4gICAgICAgICAgICBmb3JtU3RhdGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGNvbnRyb2wgPSBfZm9ybUNvbnRyb2wuY3VycmVudC5jb250cm9sO1xuICAgIGNvbnRyb2wuX29wdGlvbnMgPSBwcm9wcztcbiAgICB1c2VTdWJzY3JpYmUoe1xuICAgICAgICBzdWJqZWN0OiBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZSxcbiAgICAgICAgbmV4dDogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkUmVuZGVyRm9ybVN0YXRlKHZhbHVlLCBjb250cm9sLl9wcm94eUZvcm1TdGF0ZSwgY29udHJvbC5fdXBkYXRlRm9ybVN0YXRlLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUZvcm1TdGF0ZSh7IC4uLmNvbnRyb2wuX2Zvcm1TdGF0ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4gY29udHJvbC5fZGlzYWJsZUZvcm0ocHJvcHMuZGlzYWJsZWQpLCBbY29udHJvbCwgcHJvcHMuZGlzYWJsZWRdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoY29udHJvbC5fcHJveHlGb3JtU3RhdGUuaXNEaXJ0eSkge1xuICAgICAgICAgICAgY29uc3QgaXNEaXJ0eSA9IGNvbnRyb2wuX2dldERpcnR5KCk7XG4gICAgICAgICAgICBpZiAoaXNEaXJ0eSAhPT0gZm9ybVN0YXRlLmlzRGlydHkpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgaXNEaXJ0eSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtjb250cm9sLCBmb3JtU3RhdGUuaXNEaXJ0eV0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChwcm9wcy52YWx1ZXMgJiYgIWRlZXBFcXVhbChwcm9wcy52YWx1ZXMsIF92YWx1ZXMuY3VycmVudCkpIHtcbiAgICAgICAgICAgIGNvbnRyb2wuX3Jlc2V0KHByb3BzLnZhbHVlcywgY29udHJvbC5fb3B0aW9ucy5yZXNldE9wdGlvbnMpO1xuICAgICAgICAgICAgX3ZhbHVlcy5jdXJyZW50ID0gcHJvcHMudmFsdWVzO1xuICAgICAgICAgICAgdXBkYXRlRm9ybVN0YXRlKChzdGF0ZSkgPT4gKHsgLi4uc3RhdGUgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udHJvbC5fcmVzZXREZWZhdWx0VmFsdWVzKCk7XG4gICAgICAgIH1cbiAgICB9LCBbcHJvcHMudmFsdWVzLCBjb250cm9sXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHByb3BzLmVycm9ycykge1xuICAgICAgICAgICAgY29udHJvbC5fc2V0RXJyb3JzKHByb3BzLmVycm9ycyk7XG4gICAgICAgIH1cbiAgICB9LCBbcHJvcHMuZXJyb3JzLCBjb250cm9sXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFjb250cm9sLl9zdGF0ZS5tb3VudCkge1xuICAgICAgICAgICAgY29udHJvbC5fdXBkYXRlVmFsaWQoKTtcbiAgICAgICAgICAgIGNvbnRyb2wuX3N0YXRlLm1vdW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udHJvbC5fc3RhdGUud2F0Y2gpIHtcbiAgICAgICAgICAgIGNvbnRyb2wuX3N0YXRlLndhdGNoID0gZmFsc2U7XG4gICAgICAgICAgICBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHsgLi4uY29udHJvbC5fZm9ybVN0YXRlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2wuX3JlbW92ZVVubW91bnRlZCgpO1xuICAgIH0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHByb3BzLnNob3VsZFVucmVnaXN0ZXIgJiZcbiAgICAgICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnZhbHVlcy5uZXh0KHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGNvbnRyb2wuX2dldFdhdGNoKCksXG4gICAgICAgICAgICB9KTtcbiAgICB9LCBbcHJvcHMuc2hvdWxkVW5yZWdpc3RlciwgY29udHJvbF0pO1xuICAgIF9mb3JtQ29udHJvbC5jdXJyZW50LmZvcm1TdGF0ZSA9IGdldFByb3h5Rm9ybVN0YXRlKGZvcm1TdGF0ZSwgY29udHJvbCk7XG4gICAgcmV0dXJuIF9mb3JtQ29udHJvbC5jdXJyZW50O1xufVxuXG5leHBvcnQgeyBDb250cm9sbGVyLCBGb3JtLCBGb3JtUHJvdmlkZXIsIGFwcGVuZEVycm9ycywgZ2V0LCBzZXQsIHVzZUNvbnRyb2xsZXIsIHVzZUZpZWxkQXJyYXksIHVzZUZvcm0sIHVzZUZvcm1Db250ZXh0LCB1c2VGb3JtU3RhdGUsIHVzZVdhdGNoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20ubWpzLm1hcFxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiaXNDaGVja0JveElucHV0IiwiZWxlbWVudCIsInR5cGUiLCJpc0RhdGVPYmplY3QiLCJ2YWx1ZSIsIkRhdGUiLCJpc051bGxPclVuZGVmaW5lZCIsImlzT2JqZWN0VHlwZSIsImlzT2JqZWN0IiwiQXJyYXkiLCJpc0FycmF5IiwiZ2V0RXZlbnRWYWx1ZSIsImV2ZW50IiwidGFyZ2V0IiwiY2hlY2tlZCIsImdldE5vZGVQYXJlbnROYW1lIiwibmFtZSIsInN1YnN0cmluZyIsInNlYXJjaCIsImlzTmFtZUluRmllbGRBcnJheSIsIm5hbWVzIiwiaGFzIiwiaXNQbGFpbk9iamVjdCIsInRlbXBPYmplY3QiLCJwcm90b3R5cGVDb3B5IiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImlzV2ViIiwid2luZG93IiwiSFRNTEVsZW1lbnQiLCJkb2N1bWVudCIsImNsb25lT2JqZWN0IiwiZGF0YSIsImNvcHkiLCJTZXQiLCJCbG9iIiwiRmlsZUxpc3QiLCJrZXkiLCJjb21wYWN0IiwiZmlsdGVyIiwiQm9vbGVhbiIsImlzVW5kZWZpbmVkIiwidmFsIiwidW5kZWZpbmVkIiwiZ2V0Iiwib2JqZWN0IiwicGF0aCIsImRlZmF1bHRWYWx1ZSIsInJlc3VsdCIsInNwbGl0IiwicmVkdWNlIiwiaXNCb29sZWFuIiwiRVZFTlRTIiwiQkxVUiIsIkZPQ1VTX09VVCIsIkNIQU5HRSIsIlZBTElEQVRJT05fTU9ERSIsIm9uQmx1ciIsIm9uQ2hhbmdlIiwib25TdWJtaXQiLCJvblRvdWNoZWQiLCJhbGwiLCJJTlBVVF9WQUxJREFUSU9OX1JVTEVTIiwibWF4IiwibWluIiwibWF4TGVuZ3RoIiwibWluTGVuZ3RoIiwicGF0dGVybiIsInJlcXVpcmVkIiwidmFsaWRhdGUiLCJIb29rRm9ybUNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwidXNlRm9ybUNvbnRleHQiLCJ1c2VDb250ZXh0IiwiRm9ybVByb3ZpZGVyIiwicHJvcHMiLCJjaGlsZHJlbiIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsImdldFByb3h5Rm9ybVN0YXRlIiwiZm9ybVN0YXRlIiwiY29udHJvbCIsImxvY2FsUHJveHlGb3JtU3RhdGUiLCJpc1Jvb3QiLCJkZWZhdWx0VmFsdWVzIiwiX2RlZmF1bHRWYWx1ZXMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9rZXkiLCJfcHJveHlGb3JtU3RhdGUiLCJpc0VtcHR5T2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsInNob3VsZFJlbmRlckZvcm1TdGF0ZSIsImZvcm1TdGF0ZURhdGEiLCJ1cGRhdGVGb3JtU3RhdGUiLCJmaW5kIiwiY29udmVydFRvQXJyYXlQYXlsb2FkIiwic2hvdWxkU3Vic2NyaWJlQnlOYW1lIiwic2lnbmFsTmFtZSIsImV4YWN0Iiwic29tZSIsImN1cnJlbnROYW1lIiwic3RhcnRzV2l0aCIsInVzZVN1YnNjcmliZSIsIl9wcm9wcyIsInVzZVJlZiIsImN1cnJlbnQiLCJ1c2VFZmZlY3QiLCJzdWJzY3JpcHRpb24iLCJkaXNhYmxlZCIsInN1YmplY3QiLCJzdWJzY3JpYmUiLCJuZXh0IiwidW5zdWJzY3JpYmUiLCJ1c2VGb3JtU3RhdGUiLCJtZXRob2RzIiwidXNlU3RhdGUiLCJfZm9ybVN0YXRlIiwiX21vdW50ZWQiLCJfbG9jYWxQcm94eUZvcm1TdGF0ZSIsImlzRGlydHkiLCJpc0xvYWRpbmciLCJkaXJ0eUZpZWxkcyIsInRvdWNoZWRGaWVsZHMiLCJpc1ZhbGlkYXRpbmciLCJpc1ZhbGlkIiwiZXJyb3JzIiwiX25hbWUiLCJfdXBkYXRlRm9ybVN0YXRlIiwiX3N1YmplY3RzIiwic3RhdGUiLCJfdXBkYXRlVmFsaWQiLCJpc1N0cmluZyIsImdlbmVyYXRlV2F0Y2hPdXRwdXQiLCJfbmFtZXMiLCJmb3JtVmFsdWVzIiwiaXNHbG9iYWwiLCJ3YXRjaCIsImFkZCIsIm1hcCIsImZpZWxkTmFtZSIsIndhdGNoQWxsIiwidXNlV2F0Y2giLCJ2YWx1ZXMiLCJ1cGRhdGVWYWx1ZSIsIl9mb3JtVmFsdWVzIiwiX2dldFdhdGNoIiwiX3JlbW92ZVVubW91bnRlZCIsImlzS2V5IiwidGVzdCIsInN0cmluZ1RvUGF0aCIsImlucHV0IiwicmVwbGFjZSIsInNldCIsImluZGV4IiwidGVtcFBhdGgiLCJsYXN0SW5kZXgiLCJuZXdWYWx1ZSIsIm9ialZhbHVlIiwiaXNOYU4iLCJ1c2VDb250cm9sbGVyIiwic2hvdWxkVW5yZWdpc3RlciIsImlzQXJyYXlGaWVsZCIsImFycmF5IiwiX3JlZ2lzdGVyUHJvcHMiLCJyZWdpc3RlciIsInJ1bGVzIiwiX3Nob3VsZFVucmVnaXN0ZXJGaWVsZCIsIl9vcHRpb25zIiwidXBkYXRlTW91bnRlZCIsImZpZWxkIiwiX2ZpZWxkcyIsIl9mIiwibW91bnQiLCJfc3RhdGUiLCJhY3Rpb24iLCJ1bnJlZ2lzdGVyIiwiX3VwZGF0ZURpc2FibGVkRmllbGQiLCJmaWVsZHMiLCJ1c2VDYWxsYmFjayIsInJlZiIsImVsbSIsImZvY3VzIiwic2VsZWN0Iiwic2V0Q3VzdG9tVmFsaWRpdHkiLCJtZXNzYWdlIiwicmVwb3J0VmFsaWRpdHkiLCJmaWVsZFN0YXRlIiwiZGVmaW5lUHJvcGVydGllcyIsImludmFsaWQiLCJlbnVtZXJhYmxlIiwiaXNUb3VjaGVkIiwiZXJyb3IiLCJDb250cm9sbGVyIiwicmVuZGVyIiwiUE9TVF9SRVFVRVNUIiwiRm9ybSIsIm1vdW50ZWQiLCJzZXRNb3VudGVkIiwibWV0aG9kIiwiaGVhZGVycyIsImVuY1R5cGUiLCJvbkVycm9yIiwib25TdWNjZXNzIiwidmFsaWRhdGVTdGF0dXMiLCJyZXN0Iiwic3VibWl0IiwiaGFzRXJyb3IiLCJoYW5kbGVTdWJtaXQiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiZm9ybURhdGFKc29uIiwiSlNPTiIsInN0cmluZ2lmeSIsIl9hIiwiYXBwZW5kIiwic2hvdWxkU3RyaW5naWZ5U3VibWlzc2lvbkRhdGEiLCJpbmNsdWRlcyIsInJlc3BvbnNlIiwiZmV0Y2giLCJib2R5Iiwic3RhdHVzIiwiU3RyaW5nIiwiaXNTdWJtaXRTdWNjZXNzZnVsIiwic2V0RXJyb3IiLCJGcmFnbWVudCIsIm5vVmFsaWRhdGUiLCJhcHBlbmRFcnJvcnMiLCJ2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEiLCJ0eXBlcyIsImdlbmVyYXRlSWQiLCJkIiwicGVyZm9ybWFuY2UiLCJub3ciLCJjIiwiciIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsImdldEZvY3VzRmllbGROYW1lIiwib3B0aW9ucyIsInNob3VsZEZvY3VzIiwiZm9jdXNOYW1lIiwiZm9jdXNJbmRleCIsImdldFZhbGlkYXRpb25Nb2RlcyIsIm1vZGUiLCJpc09uU3VibWl0IiwiaXNPbkJsdXIiLCJpc09uQ2hhbmdlIiwiaXNPbkFsbCIsImlzT25Ub3VjaCIsImlzV2F0Y2hlZCIsImlzQmx1ckV2ZW50Iiwid2F0Y2hOYW1lIiwic2xpY2UiLCJpdGVyYXRlRmllbGRzQnlBY3Rpb24iLCJmaWVsZHNOYW1lcyIsImFib3J0RWFybHkiLCJjdXJyZW50RmllbGQiLCJyZWZzIiwidXBkYXRlRmllbGRBcnJheVJvb3RFcnJvciIsImZpZWxkQXJyYXlFcnJvcnMiLCJpc0ZpbGVJbnB1dCIsImlzRnVuY3Rpb24iLCJpc0hUTUxFbGVtZW50Iiwib3duZXIiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJpc01lc3NhZ2UiLCJpc1JhZGlvSW5wdXQiLCJpc1JlZ2V4IiwiUmVnRXhwIiwiZGVmYXVsdFJlc3VsdCIsInZhbGlkUmVzdWx0IiwiZ2V0Q2hlY2tib3hWYWx1ZSIsIm9wdGlvbiIsImF0dHJpYnV0ZXMiLCJkZWZhdWx0UmV0dXJuIiwiZ2V0UmFkaW9WYWx1ZSIsInByZXZpb3VzIiwiZ2V0VmFsaWRhdGVFcnJvciIsImV2ZXJ5IiwiZ2V0VmFsdWVBbmRNZXNzYWdlIiwidmFsaWRhdGlvbkRhdGEiLCJ2YWxpZGF0ZUZpZWxkIiwic2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiIsImlzRmllbGRBcnJheSIsInZhbHVlQXNOdW1iZXIiLCJpbnB1dFZhbHVlIiwiaW5wdXRSZWYiLCJpc1JhZGlvIiwiaXNDaGVja0JveCIsImlzUmFkaW9PckNoZWNrYm94IiwiaXNFbXB0eSIsImFwcGVuZEVycm9yc0N1cnJ5IiwiYmluZCIsImdldE1pbk1heE1lc3NhZ2UiLCJleGNlZWRNYXgiLCJtYXhMZW5ndGhNZXNzYWdlIiwibWluTGVuZ3RoTWVzc2FnZSIsIm1heFR5cGUiLCJtaW5UeXBlIiwiZXhjZWVkTWluIiwibWF4T3V0cHV0IiwibWluT3V0cHV0IiwidmFsdWVOdW1iZXIiLCJ2YWx1ZURhdGUiLCJ2YWx1ZUFzRGF0ZSIsImNvbnZlcnRUaW1lVG9EYXRlIiwidGltZSIsInRvRGF0ZVN0cmluZyIsImlzVGltZSIsImlzV2VlayIsIm1heExlbmd0aE91dHB1dCIsIm1pbkxlbmd0aE91dHB1dCIsInBhdHRlcm5WYWx1ZSIsIm1hdGNoIiwidmFsaWRhdGVFcnJvciIsInZhbGlkYXRpb25SZXN1bHQiLCJhcHBlbmRBdCIsImZpbGxFbXB0eUFycmF5IiwiaW5zZXJ0IiwibW92ZUFycmF5QXQiLCJmcm9tIiwidG8iLCJzcGxpY2UiLCJwcmVwZW5kQXQiLCJyZW1vdmVBdEluZGV4ZXMiLCJpbmRleGVzIiwiaSIsInRlbXAiLCJyZW1vdmVBcnJheUF0Iiwic29ydCIsImEiLCJiIiwic3dhcEFycmF5QXQiLCJpbmRleEEiLCJpbmRleEIiLCJiYXNlR2V0IiwidXBkYXRlUGF0aCIsImlzRW1wdHlBcnJheSIsIm9iaiIsInVuc2V0IiwicGF0aHMiLCJjaGlsZE9iamVjdCIsInVwZGF0ZUF0IiwiZmllbGRWYWx1ZXMiLCJ1c2VGaWVsZEFycmF5Iiwia2V5TmFtZSIsInNldEZpZWxkcyIsIl9nZXRGaWVsZEFycmF5IiwiaWRzIiwiX2ZpZWxkSWRzIiwiX2FjdGlvbmVkIiwiZmllbGRBcnJheU5hbWUiLCJ1cGRhdGVWYWx1ZXMiLCJ1cGRhdGVkRmllbGRBcnJheVZhbHVlcyIsIl91cGRhdGVGaWVsZEFycmF5IiwiYXBwZW5kVmFsdWUiLCJhcmdBIiwicHJlcGVuZCIsInByZXBlbmRWYWx1ZSIsInJlbW92ZSIsImluc2VydCQxIiwiaW5zZXJ0VmFsdWUiLCJhcmdCIiwic3dhcCIsIm1vdmUiLCJ1cGRhdGUiLCJpdGVtIiwiaXNTdWJtaXR0ZWQiLCJyZXNvbHZlciIsIl9leGVjdXRlU2NoZW1hIiwidGhlbiIsImV4aXN0aW5nRXJyb3IiLCJyZVZhbGlkYXRlTW9kZSIsImNyaXRlcmlhTW9kZSIsInVzZU1lbW8iLCJjcmVhdGVTdWJqZWN0IiwiX29ic2VydmVycyIsIm9ic2VydmVyIiwicHVzaCIsIm8iLCJvYnNlcnZlcnMiLCJpc1ByaW1pdGl2ZSIsImRlZXBFcXVhbCIsIm9iamVjdDEiLCJvYmplY3QyIiwiZ2V0VGltZSIsImtleXMxIiwia2V5czIiLCJ2YWwxIiwidmFsMiIsImlzTXVsdGlwbGVTZWxlY3QiLCJsaXZlIiwiaXNDb25uZWN0ZWQiLCJvYmplY3RIYXNGdW5jdGlvbiIsIm1hcmtGaWVsZHNEaXJ0eSIsImlzUGFyZW50Tm9kZUFycmF5IiwiZ2V0RGlydHlGaWVsZHNGcm9tRGVmYXVsdFZhbHVlcyIsImRpcnR5RmllbGRzRnJvbVZhbHVlcyIsImdldERpcnR5RmllbGRzIiwiZ2V0RmllbGRWYWx1ZUFzIiwic2V0VmFsdWVBcyIsIk5hTiIsImdldEZpZWxkVmFsdWUiLCJmaWxlcyIsInNlbGVjdGVkT3B0aW9ucyIsImdldFJlc29sdmVyT3B0aW9ucyIsImdldFJ1bGVWYWx1ZSIsInJ1bGUiLCJzb3VyY2UiLCJoYXNWYWxpZGF0aW9uIiwic2NoZW1hRXJyb3JMb29rdXAiLCJqb2luIiwiZm91bmRFcnJvciIsInBvcCIsInNraXBWYWxpZGF0aW9uIiwidW5zZXRFbXB0eUFycmF5IiwiZGVmYXVsdE9wdGlvbnMiLCJzaG91bGRGb2N1c0Vycm9yIiwiY3JlYXRlRm9ybUNvbnRyb2wiLCJmbHVzaFJvb3RSZW5kZXIiLCJzdWJtaXRDb3VudCIsImlzU3VibWl0dGluZyIsInVuTW91bnQiLCJkZWxheUVycm9yQ2FsbGJhY2siLCJ0aW1lciIsInZhbGlkYXRpb25Nb2RlQmVmb3JlU3VibWl0IiwidmFsaWRhdGlvbk1vZGVBZnRlclN1Ym1pdCIsInNob3VsZERpc3BsYXlBbGxBc3NvY2lhdGVkRXJyb3JzIiwiZGVib3VuY2UiLCJjYWxsYmFjayIsIndhaXQiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0Iiwic2hvdWxkVXBkYXRlVmFsaWQiLCJleGVjdXRlQnVpbHRJblZhbGlkYXRpb24iLCJfdXBkYXRlSXNWYWxpZGF0aW5nIiwiYXJncyIsInNob3VsZFNldFZhbHVlcyIsInNob3VsZFVwZGF0ZUZpZWxkc0FuZFN0YXRlIiwiX2dldERpcnR5IiwidXBkYXRlRXJyb3JzIiwiX3NldEVycm9ycyIsInVwZGF0ZVZhbGlkQW5kVmFsdWUiLCJzaG91bGRTa2lwU2V0VmFsdWVBcyIsImRlZmF1bHRDaGVja2VkIiwic2V0RmllbGRWYWx1ZSIsInVwZGF0ZVRvdWNoQW5kRGlydHkiLCJmaWVsZFZhbHVlIiwic2hvdWxkRGlydHkiLCJzaG91bGRSZW5kZXIiLCJzaG91bGRVcGRhdGVGaWVsZCIsImlzUHJldmlvdXNEaXJ0eSIsIm91dHB1dCIsImRpc2FibGVkRmllbGQiLCJpc0N1cnJlbnRGaWVsZFByaXN0aW5lIiwiaXNQcmV2aW91c0ZpZWxkVG91Y2hlZCIsInNob3VsZFJlbmRlckJ5RXJyb3IiLCJwcmV2aW91c0ZpZWxkRXJyb3IiLCJkZWxheUVycm9yIiwidXBkYXRlZEZvcm1TdGF0ZSIsImNvbnRleHQiLCJleGVjdXRlU2NoZW1hQW5kVXBkYXRlU3RhdGUiLCJzaG91bGRPbmx5Q2hlY2tWYWxpZCIsInZhbGlkIiwiaXNGaWVsZEFycmF5Um9vdCIsImZpZWxkRXJyb3IiLCJnZXRWYWx1ZXMiLCJmaWVsZFJlZmVyZW5jZSIsImZvckVhY2giLCJvcHRpb25SZWYiLCJzZWxlY3RlZCIsImNoZWNrYm94UmVmIiwicmFkaW9SZWYiLCJzaG91bGRUb3VjaCIsInNob3VsZFZhbGlkYXRlIiwidHJpZ2dlciIsInNldFZhbHVlcyIsImZpZWxkS2V5Iiwic2V0VmFsdWUiLCJjbG9uZVZhbHVlIiwiaXNGaWVsZFZhbHVlVXBkYXRlZCIsImdldEN1cnJlbnRGaWVsZFZhbHVlIiwiX3VwZGF0ZUlzRmllbGRWYWx1ZVVwZGF0ZWQiLCJOdW1iZXIiLCJzaG91bGRTa2lwVmFsaWRhdGlvbiIsImRlcHMiLCJ3YXRjaGVkIiwicHJldmlvdXNFcnJvckxvb2t1cFJlc3VsdCIsImVycm9yTG9va3VwUmVzdWx0IiwiX2ZvY3VzSW5wdXQiLCJmaWVsZE5hbWVzIiwiUHJvbWlzZSIsImdldEZpZWxkU3RhdGUiLCJjbGVhckVycm9ycyIsImlucHV0TmFtZSIsInBheWxvYWQiLCJkZWxldGUiLCJrZWVwVmFsdWUiLCJrZWVwRXJyb3IiLCJrZWVwRGlydHkiLCJrZWVwVG91Y2hlZCIsImtlZXBEZWZhdWx0VmFsdWUiLCJrZWVwSXNWYWxpZCIsImRpc2FibGVkSXNEZWZpbmVkIiwicHJvZ3Jlc3NpdmUiLCJmaWVsZFJlZiIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJyYWRpb09yQ2hlY2tib3giLCJfZm9jdXNFcnJvciIsIl9kaXNhYmxlRm9ybSIsInJlcXVpcmVkRGlzYWJsZWRTdGF0ZSIsIm9uVmFsaWQiLCJvbkludmFsaWQiLCJlIiwib25WYWxpZEVycm9yIiwicHJldmVudERlZmF1bHQiLCJwZXJzaXN0IiwicmVzZXRGaWVsZCIsIl9yZXNldCIsImtlZXBTdGF0ZU9wdGlvbnMiLCJ1cGRhdGVkVmFsdWVzIiwiY2xvbmVVcGRhdGVkVmFsdWVzIiwia2VlcERlZmF1bHRWYWx1ZXMiLCJrZWVwVmFsdWVzIiwia2VlcERpcnR5VmFsdWVzIiwiZm9ybSIsImNsb3Nlc3QiLCJyZXNldCIsImtlZXBTdWJtaXRDb3VudCIsImtlZXBJc1N1Ym1pdHRlZCIsImtlZXBFcnJvcnMiLCJrZWVwSXNTdWJtaXRTdWNjZXNzZnVsIiwic2V0Rm9jdXMiLCJzaG91bGRTZWxlY3QiLCJfcmVzZXREZWZhdWx0VmFsdWVzIiwicmVzZXRPcHRpb25zIiwidXNlRm9ybSIsIl9mb3JtQ29udHJvbCIsIl92YWx1ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/react-hook-form@7.50.1_react@18.2.0/node_modules/react-hook-form/dist/index.esm.mjs\n");

/***/ })

};
;